<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8">
   <meta name="created" content="2019-09-08T00:08:00">
   <meta name="changed" content="2019-09-08T00:08:00">
   <meta name="viewport" content="width=device-width, initial-scale=0.6">

   <style>
      h {
         font-size:1.3em;
         font-weight: bold;
      }
      p {
         text-align: justify;
      }
      code {
         padding:10px;
         font-family: monospace;
         display: block;
         white-space: pre;
      }
   </style>
</head>
<body style="margin:4px 5% 4px 5%">
<h>
   COPYRIGHT
</h>
<p>
   Se volete usare quanto segue, lo fate a rischio di
   incartamento. Altrimenti citate la fonte.
</p>
<h>
   Tributo a Alan Turing
</h>
<p>
   A scuola si studia che le idee di Hitler hanno causato una
   guerra di cinque anni e venti milioni di morti. Non si dice però che la
   genialità di uno dei padri dell'informatica ha ridotto la durata di due
   anni, salvando quattordici milioni di vite, tra cui probabilmente il
   nostro avo.
</p>
<h>
   Il principio di indeterminazione di Heisemberg
</h>
<p>
   Comunemente lo chiamiamo "non si può avere la botte piena e la moglie
   ubriaca". Ci sono delle <b>realtà date da piaceri psicologici</b> che non
   corrispondono alle realtà fisiologiche. La prima è che il
   fatto non si possa provare qualcosa ne il suo contrario, ci porta
   a credere all'esistenza di una qualche forma di entità superiore.
</p>
<p>
   Secondo Heisemberg il valore di qualcosa e il suo cambiamento non sono
   misurabili contemporaneamente. Se lo fosse, probabilmente saremmo fermi alla ruota di
   pietra.
</p>
<h>
   Il rapporto 80/20
</h>
<p>
   Nel '700 il matematico statista A.Pareto, stimò che le relazioni tra
   gli elementi di un dominio finiscono sempre in rapporto 
   80/20 (più o meno). Può essere che il 20% dei prodotti rendano per l'80% piuttosto
   che il 20% del codice costituisca l'80% delle performance e così via.
   IBM fece proprio questo principio negli anni '80 dichiarando che basta
   scrivere il 20% del codice in un linguaggio a basso livello.
</p>
<p>
   Facile dirsi ma ovviamente tra teoria e pratica, c'è sempre di mezzo la
   pratica.
</p>
<h>
   Paperless non è informatizzare
</h>
<p>
   Su questo basta guardare al significato della parola "informatica".
   Word, Excel e le emails fanno più casini di un modulo web o di un'app.
</p>

<h>
   I principi DRY & KISS
</h>
<p>
   "Do Not Repeat Yourself" e "Keep It Simple And Stupid" sono capi saldi
   della programmazione. C'è chi si spinge oltre con "non commentate il
   codice, riscrivetelo" ossia scrivere codice autoesplicante. Vedremo
   degli esempi.
</p>
<h>
   In principio erano i memory leak
</h>
<p>
   Quando la programmazione era solo strutturata e lo sviluppo software
   partiva quasi dal nulla, il <b>programmatore</b> doveva necessariamente <b>sviluppare diligenza</b> e
   chiudere tutto ciò che apriva.
</p>
<p>
   Poi vennero il <b>Garbage Collector e nuovi paradigmi di programmazione
   astratta</b>. L'OOP prometteva al programmatore
   di dimenticarsi tutta una serie di cose fastidiose. Il concetto
   dell'OOP nasce da un'idea di Alan Kay che però ha dichiarato di non
   aver mai voluto deviare i principi della programmazione. Il suo
   accostamento alla biologia era solo un'analogia. In realtà la biologia
   è fatta da più di due o tre livelli (classe/istanza o
   modello/classe/istanza). Con famiglia, regno e quant'altro ne ha almeno
   nove. Ridurre questa complessità comporta delle limitazioni.
</p>
<p>
   Sapere di sapere qualcosa di nuovo che gli altri non sanno, ci fa sentire più importanti. 
</p> 
<p>
   Tra le evoluzioni, scoperte o invenzioni che siano, seguirono le <b>interface</b>, poi i delegate, le promise etc. 
   Il codice con le interface, di fatto non fa niente. E' come dire che le
   scatole si faranno tutte quadrate perché dovranno contenere solo cose
   quadrate per <b>preservare l'ordine</b> (o contenere il disordine).
</p>
<p>
   La fuori ci sono gegni che non possono competere con la massa di
   limitati di cui faccio parte io. Sappiamo fin da bambini che c'è chi
   vuole far stare i triangoli nello spazio del cerchio e che le cose
   piccole stanno anche in quelle grandi. Però a volte i gegni trovano
   mega compagnie americane che investono milioni di dollari per
   evangelizzare il mondo.
</p>
<p>
   Il vero problema dell'astrazione è che da un grande potere [spiderman
   copyright], poiché si possono fare grandi danni.
</p>
<h>
   Come ammazzare un QuadCore con due righe di codice
</h>
<pre>
   S = "", I = 0
   WHILE ( I++ < 5000000 ) DO S = S + "0123456789"
</pre>
<p>
   Questo semplice programma che esegue il concatenamento di 10 caratteri
   per 5 milioni di volte, richiede solo 5MB di memoria, dei GB di cui sono dotati i computer moderni. 
   E' un esempio forzato, ma su un
   processore a 3GHz, verrebbe eseguito in un millesimo di secondo
   (1/3000000000*5000000).
</p>
<p>
   In pratica arriverà invece a saturare anche un computer potente,
   poiché quella che dovrebbe essere un concatenamento (progressivo) è in
   realtà una somma, ossia un'operazione ripetitiva che si porta dietro il
   lavoro precedente (vorrei sapere come Haskell risolve questa
   cosa, se lo fa).
</p>
<p>
   Chi NON ha esperienza di programmazione assembler o C potrebbe non
   scoprirlo mai, concludendo che sia necessario scalare l'hardware.
</p>
<h>
   GUID per ogni occasione
</h>
<p>
   Vedo spesso usare il GUID come chiave per ovvie ragioni di
   unicità. E' utile soprattutto in previsione di una sincronizzazione tra
   sistemi diversi anche se appartenenti alla stessa soluzione (es.
   mobile<->server). Anche questa è una soluzione psicologicamente di
   comodo. Un INT indirizza quattro miliardi di records ed è più che
   sufficiente.
</p>
<p>
   Quel che un programmatore sa è che un INT occupa 4bytes e un GUID
   16bytes. Può non sapere è che un
   processore a 32 o 64 bit ha una word di registro che contiene l'INT ma
   ne deve impiegare 2 o 4 per un GUID. Ciò vuol dire che (sempre per esempio
   forzato), un processore a 3GHz può gestire 3 miliardi di ID di tipo INT
   al secondo. La metà o 1/4 se GUID.
</p>
</p>
   Le implicazioni sono tante. Ho potuto però dimostrare ai membri del mio
   team che una sincronizzazione PDA/SERVER che mandava in crash il PDA
   con 3000 records con GUID, raggiungeva i 15000 con l'INT. Poi
   abbiamo risolto mandando l'intero archivio, ma non ho detto loro che si
   poteva migliorare di un fattore 10 le prestazioni con un semplice [segreto].
</p>
<h>
   La ricerca è lenta, aggiungiamo un indice
</h>
<p>
   Rimanendo in tema databases, mi è capitato tanto di dover spiegare cosa
   e come aggiungere indici, quanto perché toglierli o fare a meno. Se da
   una parte è abbastanza intuibile che un indice appesantisce la fase di
   scrittura, si pensa meno che una scrittura può implicare una
   lettura e comunque la concorrenza con altre letture in un ambiente
   condiviso e con hardware monolitico.
</p>
<p>
   Per questioni di scelte progettuali, questo problema può rendere
   addirittura un prodotto gratuito come <b>Postresql più interessante di una
   licenza MSSql</b> Server Enterprise da 150.000€.
</p>
<p>
   Ma <b>quel che sfugge</b> per carenza di knowledge base (KB) è che una lettura
   tramite indice può sfociare in una ricerca di una pagina come fosse
   <b>sparpagliata in una stanza assieme alle altre</b>. Per capire è
   necessaria la grafica.
</p>
<p>
   Convenzionalmente ci raffiguriamo un indice con la sua tabella come da
   seguente figura.
</p>

   <img src="../images/dbidxtbl.png">  fig.1

<p>
   Nel vecchio dBase o Firefox, queste due strutture costituivano due
   files. Per questioni di comodità, oggi finiscono in un unico file che
   viene rappresentato come segue.
</p>

   <img src="../images/dbsinglefile.png"> fig.2

<p>
   La figura 2 verrebbe utile per far capire perché MSSQL richiede meno
   risorse di Oracle ma allo stesso tempo degrada esponenzialmente in
   performance. Non è questo però l'oggetto del paragrafo.
</p>
<p>
   Questa vista logica, nella realtà diventa qualcosa di simile alla seguente
   immagine.
</p>

   [image006.png] fig.3

<p>
   Ricordo che sono delle rappresentazioni forzate. Lo sparpagliamento può essere minore,
   grazie alle proprietà del file system o alle capacità del sistema
   operativo ma può essere anche maggiore a seconda della configurazione
   software o hardware.
</p>
<p>
   Questo vale sia che si parli di SQL che di noSQL. Già qualche ex
   sostenitore del noSQL si sta ricredendo.
</p>

<h>
   JSON? Mmh, maybe later
</h>
<p>
   Adoro il formato JSON. Semplice ed elegante da scrivere, comodo da
   modificare, impossibile da ristrutturare e non supporta stringhe multi riga. 
   Alla fine consuma quanto l'XML. 
   L'ho usato per realizzare il CV dinamico. Poi l'ho voluto semplificare. E' stato più
   facile rifare o riciclare che trasformare. Se lo rifacessi
   userei dei TXT formattati come mi pare, ma sarebbe un altro delirio.
</p>
<p>
   JSON in SQL o noSQL? Un bel dilemma? Mmh, Javascript è nato per rappresentare, non per trasformare.<br>
   Poi uno è libero di portarsi tutti i dati lato client e fargli fare gli WHERE e i GROUPBY che vuole.
</p>

<h>
   E poi vennero Web e Cloud
</h>
<p>
   Sento spesso lamentare del fatto che il browser web impegna la CPU al
   100% o del timore delle applicazioni web, soprattutto SPA, per il consumo di memoria. 
   Eppure le applicazioni
   web, per la loro natura distribuita, dovrebbero ridurre questi problemi
   rispetto alle vecchie applicazioni client/server.  Perché non è così?
</p>
<p>
   Partiamo dalla CPU. Perché è lecito comprare una Ferrari che fa i
   300Km/h quando i limiti di velocità sono inferiori, ma non va bene se
   un'unità di calcolo viene sfruttata al massimo?
</p>
<p>
   L'applicazione web gira in uno dei tab del browser che è
   un'applicazione che gira nel sistema operativo assieme ai venti fogli
   Excel o documenti Word aperti contemporaneamente. Quel che una vecchia
   applicazione client nativa faceva senza dire niente a nessuno era
   spesso impiegare tanti files temporanei senza poi pulire.
</p>
<p>
   Con questo voglio solo concludere che per il principio di Heisemberg,
   non si può fare un'applicazione a prova di utonto o webete.
</p>
<p>
   O meglio, se lo chiedete a me, ve la posso fare, ma per onestà
   intellettuale vi chiederei:
</p>
<p>
   "Siete pronti a spendere più di quanto costerebbe scrivere due
   documenti in croce e fare formazione, magari implementando CMS o
   documentali o di knowledge sharing in genere?"
</p>
<p>
   Certo bisogna assumere le persone giuste, soprattutto quelle che si
   occupano dell'assunzione delle persone giuste.
</p>

<h>
   Ho visto cose che voi umani...
</h>
<pre>
   <b>TRY</b>

         VARIABILE = ALTRA_VARIABILE

   <b>END TRY</b>
</pre>
<p>
   Abbiamo visto tutti almeno una volta usare eccezioni a modo di:
   "Chissenefrega, basta che non si spacchi che puoi vendere bugs come
   fossero features":
</p>
<p>
   Ho visto programmi C++ che facevano un uso raffinato, quasi inebriante, dei templates
   (AGG). Quando è venuto il momento di usarli ho
   lasciato perdere dopo essermi accorto anche che quando il gioco si fa
   duro, solo l'hardware può giocare e non c'è ottimizzazione software che tenga.
</p>
<p>
   Ho visto programmi fare uso di interface in maniera magistrale, in un
   potpourri di codice auto esplicante. Poi è arrivato il <b>neolaureato con
   esperienza</b> (o <b>NcE</b>, che non esiste ma che il 60% degli annunci italiani
   ricerca) assunto da selezionatore altrettanto Nce, in
   barba ad Heisemberg. Naturalmente c'è un referente che sa tutto ma non
   dice niente e non ha mai avuto il tempo di scrivere l'ABC. Anch'egli è
   pagato per fare più che raccontare. Altro che metodo Toyota o principio
   80/20. Tra teoria e pratica non c'è nient'altro che un muro.
</p>
<p>
   Il nostro NcE guarda il problema diritto negli occhi e capisce che ha
   bisogno di weaponX(). Funzione, classe o metodo che sia, la implementa.
   Un colpo al cerchio e uno alla botte e va che è un piacere.
   Quando diventa esperto anche dell'applicazione, scopre che esisteva già
   e si chiamava weapon_YX(). Ormai è tardi per riscrivere il codice
   perché c'è un nuovo problema all'orizzonte o addirittura un nuovo
   lavoro. Così il nuovo NcE wrappa weaponX su weapon_YX giusto per
   mettere un poco di ordine senza sconvolgere. Poi arriva il nuovo NcE.
</p>
<p>
   Ho provato a imporre il prefisso TMP alle tabelle temporanee ma alla fine
   l'azienda ha preferito licenziarmi e investire il ricavato in apprendisti.
</p>
<p>
   E poi ho visto banali "SELECT qualcosa FROM tabella WHERE condizione"
   seppellite sotto strati e strati di codice da far piangere (è la
   cosiddetta programmazione a cipolla :-)
</p>

<h>
   Jenkins e gli Hyper Tests
</h>
<p>
   Per quanto sopra (frammentazione del codice) e per questioni di
   sicurezza (con tutta la gente che si assume e se ne va), 
   si sono resi necessari i sistemi automatizzati di
   compilazione e test. Proprio come facevo 25 anni fa quando programmavo in C.
   Poi per mancanza di tempo (cioé soldi) ho dovuto abbandonare.
</p>
<p>
   A quel tempo le grosse applicazioni si dividevano verticalmente in
   librerie e orizzontalmente in chunks di funzioni. Oggi ci sono i
   namespaces e le classi ma dobbiamo mettere i progetti nei posti sbagliati
   solo perché le soluzioni non prevedono links simbolici.
</p>

<h>
   Complichiamoci la vita
</h>
<p>
   Nel tentativo di semplificarmi la vita, per amore
   della scoperta e tanti altri motivi ignobili, mi sono complicato la vita.
</p>
<p>
   Cosa c'era di male in:
</p>
<pre>
   <b>function</b> ClientiInsolventi( filtro ) {

      <b>return</b> db("SELECT campoA, campoB, campoC FROM tabella WHERE campoD = {filtro}")

   }
</pre>
<p>
   che è compatibile con il 90% dei db engine compatibili SQL92? Al più si
   mette un IF dbEngine=X THEN ... ELSE ... in funzione del rapporto di
   Pareto. Soprattutto rispetta i principi DRY, KISS.
</p>
<p>
   Ma anche io ho preferito qualcosa tipo:
</p>
<pre>
   ClientiInsolventi Insolventi = db.From&lt;ClientiInsolventi&gt;()

             .Where(x => x.campoD = filtro)

             .Select(x => <b>new</b> { x.campoA, x.CampoB, x.CampoC }

   )
</pre>
<p>
   che è compatibile con il semanthic check dell'IDE ma difficile da scrivere
   e specifico di uno dei tanti linguaggi general pourpose. Poi comunque
   diviene la SELECT di sopra o non si sa cosa, perché nessuno ha ancora
   scritto il driver ORM completo per questo o il prossimo engine SQL, noSQL, a colonne o
   cloud.
</p>
<p>
   <b>Gli ORM come l'OOP danno quel piacere psicologico non verificabile.</b> Non
   penso che SAP, che se lo potrebbe permettere, riscriverebbe SAP solo
   per il gusto di provare se è vero che ORM e OOP semplificano e
   migliorano la vita. JdEdwards ci ha provato e sono falliti prima di
   finire.
</p>
<p>
   Con le moderne tecniche di Jenkins e la sua band, un
   metodo vale l'altro. Il primo è preferibile perché lo si riscrive 10
   volte più velocemente. Questo solo per dire che anche lo sviluppo
   software è un eco-sistema.
</p>

<h>
   Vedo il tuo bug e rilancio con un deadlock di classi
</h>
<p>
   Qualsiasi linguaggio è un sistema circolare per natura. La "parola" non
   è la "cosa". A parole, tutto può diventare il suo contrario. Non c'è
   astrazione che lo impedisca. Proprio noi italiani siamo maestri
   in questo.
</p>
<p>
   Un'azienda da un servizio tramite i suoi membri che lo danno anche
   privatamente. Solo pensare agli eventuali conflitti, alle conseguenze e
   alla loro gestione è un costo non indifferente che cozzerà anche con il
   sistema di livello superiore (il contenitore).
</p>
<p>
   Tutto parteda un individuo che fa una cosa. Un'altro lo vede e lo
   fa anche lui. Arriva l'osservatore che dice:"Hei, ci sono due entità
   che adottano comportamenti comuni. Facciamone un modello!". Fatto il
   modello, lo si applica in scala e diventa un disastro che sta in piedi
   solo per inerzia.
</p>
<p>
   Non bastano due gambe per tenere in piedi un tavolo
</p>
<p>
   Per rispondere all'opinione di un Duca, i matematici hanno impiegato
   600 anni per dimostrare che non era matematicamente possibile stivare
   le palle di cannone meglio di come i contadini facevano con le arance.
</p>
<p>
   La tridimensionalità è una condizione minima per non
   incappare in errori concettuali. E' una regola che applico
   anche nell'UI design, ma questo è un altra questione.
</p>

<h>
Kiss me the code
</h>
<p>
   Il seguente esempio è tratto dal testo "Clean Code". In alto a destra
   c'è il codice d'origine. A sinistra la revisione dell'autore. In basso
   a destra la mia versione.
</p>
<p>
   L'autore spezza il funzioni più piccole, auto-esplicanti. Non tutti i
   linguaggi consentono nested functions. Una classe non avrebbe senso
   (figuriamoci condita di interfaces :-)
</p>
<p>
   La mia versione sembra scritta da un bambino ordinato, ma fa
   di più. Sempre per il principio di Heisemberg, non si può ottimizzare
   sia per tempo che per spazio. Quindi ho usato "più memoria" replicando
   parti di stringa, in violazione del principio DRY. Il codice è più
   compatto, leggibile, capibile dai vecchi come me e dai NcE. Con il
   tempo risparmiato, ho aggiunto l'internazionalizzabilità.
</p>
<p>
   Rimane incasinabile ma lo trovo improbabile. Si fa prima a
   rifare tutto, riciclando questo codice come pseudo-code.
</p>
<p>
   Ho detto di aver violato il principio DRY ma ritengo che, a livello
   strutturale, lo è anche fare più funzioni. La mia
   violazione del DRY preserva il KISS.
</p>
<div style="display:inline-block; width:100%">
   <code style="background-color: #2196f3; float:left; display: inline-block; vertical-align: top;">
   <b>// "Clean code" (pg. 28,29)</b>

   <b>private</b>
   <b>void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>public</b> string make(
         <b>char</b> candidate, <b>int</b> count
     )
     {
        createPluralDependentMessageParts(count);

        <b>string</b> guessMessage = string.format(
           "There %s %s %s%s",
           verb, number, candidate,
           pluralModifier
           );

        print(guessMessage);
     }

     <b>private
     void</b> createPluralDependentMessageParts(
         <b>int</b> count
     )
     {
        <b>if</b> (count == 0) thereAreNoLetters();
        <b>else if</b> (count == 1) thereIsOneLetter();
        <b>else</b> thereAreManyLetters(count);
     } // createPluralDependentMessageParts

     <b>private
     void</b> thereAreManyLetters(<b>int</b> count)
     {
        number = integer.toString(count);
        verb = "are";
        pluralModifier = "s";
     } // thereAreManyLetters

     <b>private
     void</b> thereIsOneLetter()
     {
        number = "1";
        verb = "is";
        pluralModifier = "";
     }

     <b>private
     void</b> thereAreNoLetters()
     {
        number = "no";
        verb = "are";
        pluralModifier = "s";
     } // thereAreNoLetters

   } // printGuessStatistics
   </code>

   <div style="float:left; display:grid;">

   <code style="background-color: #8bc34a; display: inline-block; vertical-align: top;">
   <b>// the original code</b>

   <b>private
   void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>if</b> (count == 0) {
        
        number = "no";
        verb = "are";
        pluralModifier = "s";

     } <b>if</b> (count == 1) {

        number = "1";
        verb = "is";
        pluralModifier = "";

     } <b>else</b> {

        number = integer.toString(count);;
        verb = "are";
        pluralModifier = "s";

     }

     <b>string</b> guessMessage = string.format(
        "There %s %s %s%s",
        verb, number, candidate,
        pluralModifier
        );

     print(guessMessage);
   }
   </code>

   <code style="background-color: #ffeb3b; display: inline-block; vertical-align: top;">
   <b>// my revision</b>

   <b>void</b> printGuessStatistics( 
      <b>char</b> candidate, 
      <b>int</b> count 
      )
   {
      string msg;

      <b>if</b> (count == 0)
         msg = TR("There are no {0}s",candidate);

      <b>else if</b> (count == 1)
         msg = TR("There is 1 {0}",candidate);

      <b>else if</b> (count > 1)
         msg = TR("There are {0} {1}s", count, candidate);

      print(msg);
   } // printGuessStatistics
   </code>
   </div>
</div>
<p>
   Se volete commentare, contattatemi <img src="../images/contact_info_email.jpg">
   06.08.2018 Stefano Zaglio
</p>
<pre>
   _______________________________________________________________________

   Fonti bibliografiche
   "Software sytems, failure and success" Pattersons, C.Jones
   "Clean code" Prentice Hall, R.C.Martin
   "Programmazione orientata agli oggetti" Addison Wesley, Brad J.Cox
   "Pragmatic Programmer: From Journeyman to master" Addison Wesley,A.Hunt, D.Thomas
   “Tinycc-devel - mailing list”
   "Da software house a impresa di servizi" Mondadori, M.Bolognani
   "Dai sistemi al pensiero sistemico" FrancoAngeli, P.Mella
   "Oltre la qualità totale" FrancoAngeli, G.Dellacasa, S.Moncini
   "Il principio 80/20. Il segreto per ottenere di più con meno" FrancoAngeli, R.Koch
   "Usiamo la testa" e "Mappe mentali" Frassinelli, Tony Buzan
   "Change" Astrolabio, P.Watzlawick, J.H.Weakland, R.Fish
   "Perchè non possiamo non dirci darwinisti" Rizzoli, E.Boncinelli (2009)
   "Il computer di Dio" e "Il diavolo in cattedra" di Piergiorgio Odifreddi (2000-2003)
   "Verso un'ecologia della mente" Adelphi, G.Bateson (1977)
   “Sviluppare il pensiero nel ritardo mentale” Erickson, P.L. Baldi
   "L'arte di imparare" Mondadori, B.Carey
   [1]Esperienza personale

</pre>
</body>
</html>
