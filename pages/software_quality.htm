<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8">
   <meta name="created" content="2019-09-09T00:09:00">
   <meta name="changed" content="2019-09-09T00:09:00">
   <meta name="viewport" content="width=device-width, initial-scale=0.6">

   <style>
      h {
         font-size:1.3em;
         font-weight: bold;
      }
      p {
         text-align: justify;
      }
      code {
         padding:10px;
         font-family: monospace;
         display: block;
         white-space: pre;
      }
	  .orange {
		color: orange;
	  }
	  cmd {
		color: purple;
	  }
	  op {
		color: red;
	  }
   </style>
</head>
<body style="margin:4px 5% 4px 5%">
<h>
   COPYRIGHT
</h>
<p>
   Se volete usare quanto segue, lo fate a rischio di
   incartamento. Altrimenti citate la fonte.
</p>
<h>
   Tributo a Alan Turing
</h>
<p>
   A scuola si studia che le idee di Hitler hanno causato una
   guerra di cinque anni e venti milioni di morti. Non si dice però che la
   genialità di uno dei padri dell'informatica ne ha ridotto la durata di due
   anni, salvando quattordici milioni di vite, tra cui probabilmente il
   nostro avo.
</p>
<h>
   Il principio di indeterminazione di Heisemberg
</h>
<p>
   Quando non possiamo provare o negare qualcosa, si crea una credenza basata sul piacere psicologico che più l'attrae.
<p>
   Heisemberg ha determinato che il valore di qualcosa e il suo cambiamento non sono
   misurabili contemporaneamente. 
</p>
<p>
	Quindi non esiste niente di meglio di qualcos'altro, soprattutto, come si vedrà, i sistemi linguistici.
</p>
<h>
   Il rapporto 80/20
</h>
<p>
   Nel '700 il matematico statista A.Pareto, stimò che le relazioni tra
   gli elementi di un dominio finiscono sempre in rapporto 
   80/20 (più o meno). Può essere che il 20% dei prodotti rendano per l'80% come
   che il 20% del codice costituisca l'80% delle performance e così via.
   IBM fece proprio questo principio negli anni '80 dichiarando che basta
   scrivere il 20% del codice in un linguaggio a basso livello (C a quei tempi).
</p>
<p>
   Facile dirsi ma ovviamente tra teoria e pratica, c'è sempre di mezzo la
   pratica.
</p>
<h>
   Paperless non è informatizzare
</h>
<p>
   Il significato della parola "informatica" non è:"togliamo la carta", come è accaduto con pergamene e tavole di pietra.
   Word, Excel ed emails sono stati utili ma fanno più casini di un modulo web o di un'app.
</p>

<h>
	Chiudere la porta
</h>
<p>
	"Chiudere la porta" è un comando che non esprime il processo. Poiché i miei figli la sbattono e la mia auto è vecchiotta,
	ho spiegato loro di "accompagnarla fino a 10cm dalla chiusura e poi chiuderla".
</p>

<h>
   I principi DRY & KISS
</h>
<p>
   "Do Not Repeat Yourself" e "Keep It Simple And Stupid" sono capi saldi
   della programmazione. C'è chi si spinge oltre con "non commentate il
   codice, riscrivetelo" ossia scrivere codice autoesplicante. Vedremo
   degli esempi.
</p>
<h>
   In principio erano i memory leak
</h>
<p>
   Quando la programmazione era solo strutturata e lo sviluppo software
   partiva quasi dal nulla, il <b>programmatore</b> doveva necessariamente <b>sviluppare diligenza</b> e
   chiudere tutto ciò che apriva.
</p>
<p>
   Poi vennero il <b>Garbage Collector e nuovi paradigmi di programmazione
   astratta</b> che ancora oggi promettono al programmatore
   di poter dimenticare di tutta una serie di fastidiosi doveri. Il concetto
   dell'OOP nasce da un'idea di Alan Kay che però ha dichiarato di non
   aver mai voluto deviare dai principi della programmazione. Il suo
   accostamento alla biologia era solo un'analogia. La biologia
   tratta più di due o tre livelli (classe/istanza o
   modello/classe/istanza). Con famiglia, regno e quant'altro ne ha almeno
   nove. Semplificare questa complessità ha delle conseguenze.
</p>
<p>
   Tra le evoluzioni, scoperte o invenzioni che siano, seguirono le <b>interface</b>, poi i delegate, le promise etc. 
   Il codice con le interface, di fatto non fa niente. E' come dire che le
   scatole si faranno tutte quadrate perché dovranno contenere solo cose
   quadrate per preservare l'ordine ossia <b>contenere il disordine</b>.
</p>
<p>
   La fuori ci sono gegni che non possono competere con la massa di
   limitati di cui faccio parte io. Sappiamo dai bambini che c'è chi
   vuole far stare i triangoli nello spazio del cerchio e che le cose
   piccole stanno anche in quelle grandi. Però a volte i gegni trovano
   mega compagnie americane che investono milioni di dollari per
   evangelizzare il mondo.
</p>
<p>
   Il problema dell'astrazione è che da un grande potere [spiderman
   copyright], poiché si possono fare grandi danni.
</p>
<h>
   Come ammazzare un QuadCore con due righe di codice
</h>
<p>
	Quando ho cominciato questo mestiere, le CPU erano a 4Mhz e i computer avevano 16KB di RAM, grafica inclusa.
</p>
<pre>
   S = "", I = 0
   <b>WHILE</b> ( I++ < 5000000 ) <b>DO</b> S = S + "0123456789"
</pre>
<p>
   Questo semplice programma esegue il concatenamento di 10 caratteri
   per 5 milioni di volte. Richiede solo 1/1000 della memoria di cui sono dotati i computer moderni. 
   E' un esempio forzato, ma su un processore a 3GHz, verrebbe eseguito in un millesimo di secondo
   (1/3000000000*5000000).
</p>
<p>
   In pratica arriverà invece a saturare anche un computer potente,
   poiché quella che dovrebbe essere un concatenamento (progressivo) è in
   realtà una somma, ossia un'operazione ripetitiva che si porta dietro il
   pregresso.
</p>
<p>
   Il C++ capisce che la somma è un concatenamento ed ottimizza. C# non lo faceva, almeno fino alla versione 6.
   Vorrei sapere se Haskell lo fa e come risolve questa situazione.
</p>
<p>
   Chi NON ha esperienza di programmazione assembler o C potrebbe non
   scoprirlo mai, concludendo che sia necessario scalare l'hardware.
</p>
<h>
   GUID per ogni occasione
</h>
<p>
   Vedo spesso usare il GUID come chiave per ovvie ragioni di
   unicità. E' utile soprattutto in previsione di una sincronizzazione tra
   sistemi diversi anche se appartenenti alla stessa soluzione (es.
   mobile<->server). Anche questa è una soluzione psicologicamente di
   comodo. Un INT indirizza quattro miliardi di records ed è più che
   sufficiente.
</p>
<p>
   Quel che un programmatore sa è che un INT occupa 4bytes e un GUID
   16bytes. Può non sapere che un
   processore a 32 ha una word di registro che contiene l'INT ma
   ne deve impiegare 4 per un GUID. Ciò vuol dire che (sempre esempio
   forzato), un processore a 3GHz potrebbe gestire 3 miliardi di ID di tipo INT
   al secondo. Diventano 700 milioni in caso di GUID. Ovviamente sappiamo che già questo numero va ben oltre la realtà.
</p>
</p>
   Le implicazioni sono tante. Ho potuto però dimostrare ai membri del mio
   team che una sincronizzazione PDA/SERVER che mandava in crash il PDA
   con 3000 records con GUID, raggiungeva i 15000 con l'INT. Poi
   abbiamo risolto mandando l'intero archivio, ma non ho detto loro che si
   poteva migliorare di un fattore 10 le prestazioni con un semplice [segreto].
</p>
<h>
   La ricerca è lenta, aggiungiamo un indice
</h>
<p>
   Rimanendo in tema databases, mi è capitato tanto di dover spiegare cosa
   e come aggiungere indici, quanto <b>perché toglierli o fare a meno</b>. Se da
   una parte è abbastanza intuibile che un indice appesantisce la fase di
   scrittura, si pensa meno che una scrittura può implicare una
   lettura. Figuriamoci in ambiente ad alta concorrenza, magari su server monolitico.
</p>
<p>
   Per questioni di scelte progettuali, questo problema può rendere
   addirittura un prodotto gratuito come <b>Postresql più interessante di una
   licenza MSSql</b> Server Enterprise da 150.000€.
</p>
<p>
   Ma <b>quel che sfugge</b> per carenza di knowledge base (KB) è che una lettura
   tramite indice può sfociare certamente in una letura diretta di una pagina, ma questa è come
   <b>sparpagliata in una stanza assieme alle altre</b>. Vediamo la grafica.
</p>
<p>
   La figura 1 è una raffigurazione convenzione di indice a sinistra e tabella a destra.
</p>

   <img src="../images/dbidxtbl.png">  fig.1

<p>
   Nel vecchio dBase, queste due strutture costituivano due
   files. Oggi finiscono in un unico file rappresentabile come in figura 2.
</p>

   <img src="../images/dbsinglefile.png"> fig.2

<p>
   La figura 2 verrebbe utile per far capire perché MSSQL richiede meno
   risorse di Oracle ma allo stesso tempo degrada esponenzialmente in
   performance. Non è questo però l'oggetto del paragrafo.
</p>
<p>
   Questa vista logica, nella realtà diventa qualcosa di simile alla figura 3.
</p>

   <img src="../images/dbdisk.png"> fig.3

<p>
   Ricordo che sono delle rappresentazioni forzate. Lo sparpagliamento può essere minore,
   grazie alle proprietà del file system o alle capacità del sistema
   operativo ma può essere anche maggiore a seconda della configurazione
   software o hardware. Quando non sono HP e Oracle a lavorare assieme, 
   spesso le configurazioni software e hardware non c'entrano nulla l'una con l'altra.
</p>
<p>
   Questo vale sia per SQL che noSQL. Già qualche
   sostenitore del noSQL si sta ricredendo. Ne ho visti tanti di entusiasmi smorzarsi dopo il primo decennio.
   Se ci sono più di 800 linguaggi di programmazione ma il C rimane tra i primi 10 più usati, ci sarà un motivo.
   Mi stupisce sempre sentire di performance eccelse di strumenti quali ad esempio Node.js.
   Azzarderei a dire che le performance di sviluppo sono inversamente proporzionali alle prestazioni di runtime.
</p>

<h>
   JSON? Mmh, maybe later
</h>
<p>
   Adoro il formato JSON. Semplice ed elegante da scrivere, comodo da
   modificare, impossibile da ristrutturare e non supporta stringhe multi riga. 
   Alla fine consuma quanto l'XML. 
   L'ho usato per realizzare il mio CV dinamico. Poi l'ho voluto semplificare. E' stato più
   facile rifare o riciclare che trasformare. Se lo rifacessi
   userei dei TXT formattati come mi pare, ma sarebbe un altro delirio perché Javascript non è nato per questo.
</p>
<p>
   JSON in SQL o noSQL? Un bel dilemma? Javascript era nato per rappresentare.<br>
   Poi uno è libero di portarsi tutti i dati lato client e fargli fare gli WHERE e i GROUPBY che vuole.
</p>

<h>
   E poi vennero Web e Cloud
</h>
<p>
   Sento spesso lamentare del fatto che il browser web impegna la CPU al
   100% o del timore delle applicazioni web, soprattutto SPA, per il consumo di memoria. 
   Eppure le applicazioni
   web, per la loro natura distribuita, dovrebbero ridurre questi problemi
   rispetto alle vecchie applicazioni client/server.  Perché non è così?
</p>
<p>
   Partiamo dalla CPU. Perché è lecito comprare una Ferrari che fa i
   300Km/h quando i limiti di velocità sono inferiori, ma non va bene se
   un'unità di calcolo viene sfruttata al massimo?
</p>
<p>
   L'applicazione web gira in uno dei tab del browser che è
   un'applicazione che gira nel sistema operativo assieme ai venti fogli
   Excel o documenti Word aperti contemporaneamente. Quel che una vecchia
   applicazione client nativa faceva senza dire niente a nessuno era
   spesso impiegare tanti files temporanei senza poi pulire.
</p>
<p>
   Con questo voglio solo concludere che per il principio di Heisemberg,
   non si può fare un'applicazione a prova di utonto o webete.
</p>
<p>
   O meglio, se lo chiedete a me, ve la posso fare, ma per onestà
   intellettuale vi chiederei:
</p>
<p>
   "Siete pronti a spendere più di quanto costerebbe scrivere due
   documenti in croce e fare formazione, magari implementando CMS o
   documentali o di knowledge sharing in genere?"
</p>
<p>
   Certo bisogna assumere le persone giuste, soprattutto quelle che si
   occupano dell'assunzione delle persone giuste.
</p>

<h>
   Ho visto cose che voi umani...
</h>
<pre>
   <b>TRY</b>

         VARIABILE = ALTRA_VARIABILE

   <b>END TRY</b>
</pre>
<p>
   Abbiamo visto tutti almeno una volta usare eccezioni a modo di:
   "Chissenefrega, basta che non si spacchi che puoi vendere bugs come
   fossero features":
</p>
<p>
   <b>Ho visto</b> programmi C++ che facevano un uso raffinato, quasi inebriante, dei templates
   (AGG). Quando è venuto il momento di usarli ho
   lasciato perdere dopo essermi accorto anche che quando il gioco si fa
   duro, solo l'hardware può giocare e non c'è ottimizzazione software che tenga.
</p>
<p>
   <b>Ho visto</b> programmi fare uso di interface in maniera magistrale, in un
   potpourri di codice auto esplicante. Poi è arrivato il <b>neolaureato con
   esperienza</b>. Il <b>NcE</b> esiste per convenzione del 60% degli annunci di ricerca italiani.
   In barba ad Heisemberg viene assunto da selezionatori Nce. 
   Naturalmente c'è un referente che sa tutto ma non
   dice niente e non ha mai avuto il tempo di scrivere l'ABC. 
   Altro che metodo Toyota o principio 80/20. Tra teoria e pratica non c'è nient'altro che un muro.
</p>
<p>
   Fresco di tutte le sante neo teorie accademiche, il nostro NcE guarda il problema diritto negli occhi e capisce che ha
   bisogno di weaponX(). Funzione, classe o metodo che sia, la implementa.
   Un colpo al cerchio e uno alla botte e va che è un piacere.
   Quando diventa esperto anche dell'applicazione, scopre che esisteva già
   e si chiamava weapon_YX(). Ormai è tardi per riscrivere il codice
   perché c'è un nuovo problema all'orizzonte o addirittura un nuovo
   lavoro. Così il nuovo NcE wrappa weaponX su weapon_YX giusto per
   mettere un poco di ordine senza sconvolgere. Poi arriva il nuovo-nuovo NcE.
</p>
<p>
   <b>Ho visto</b> usare prefissi "XXX_","AAA_" e altro alle tabelle temporanee dove avevo imposto il prefisso TMP. Alla fine
   l'azienda ha preferito licenziarmi e investire il ricavato in altri apprendisti. Tutto questo mentre stavo sviluppando triggers DDL che istruissero gli apprendisti all'uso corretto di nomi e commenti.
</p>
<p>
   <b>Ho visto</b> banali <span class="orange">"SELECT qualcosa FROM tabella WHERE condizione"</span>
   seppellite sotto strati e strati di codice da far piangere (è la
   cosiddetta programmazione a cipolla :-)
</p>
<p>
	<b>Ho visto</b> professionisti scrivere codice inutilmente suvrastrutturato, perché erano abituati così e per loro era più facile e veloce.
</p>
<p>
	<b>Ho visto</b> utenti dichiarare che il programma aveva dato errore X ma senza visualizzare il messaggio.
</p>
<p>
	<b>Ho visto</b> l'help desk segnalare malfunzionamenti per errori di programmazione, legati a difetti di progettazione, venir risolti con interventi di programmazione, lasciando il difetto. 
	Mi suona un poco come mettere la colla tra parti in metallo o i freni di una bicicletta ad un jumbo.
</p>

<h>
   Jenkins e gli Hyper Tests
</h>
<p>
   Per quanto sopra (frammentazione del codice o mal progettazione) e per questioni di
   sicurezza (con tutta la gente che si assume e se ne va), 
   si sono resi necessari i sistemi automatizzati di
   compilazione e test. Proprio come facevo 25 anni fa quando programmavo in C, anche se ero da solo.
</p>
<p>
   A quel tempo le grosse applicazioni si dividevano verticalmente in
   librerie e orizzontalmente in chunks di funzioni. Oggi ci sono i
   namespaces e le classi ma dobbiamo mettere i progetti nei posti sbagliati
   solo perché le soluzioni non prevedono links simbolici.
</p>
<p>
	Testare è una scienza o un'arte? Mi chiedo questo perché la scienza sa di non sapere ciò che a volte i tests presuppongono di conoscere. 
	<ul>
		<li>
			Quanto costa, testare le differenze di rappresentazione tra Firefox e Chrome?
		</li>
		<li>
			Come fare a testare una procedura basata su un input casuale dell'utente?
		</li>
		<li>
			Ha senso fare un test su una funzione deterministica? O una funzione tipo ADD(X,Y)?
		</li>
		<li>
			Come fare a testare la mancanza di formazione nell'utente che dice che il programma non va perché manca la carta nella stampante?
		</li>
		<li>
			E quando l'utente dice che il programma è andato in errore ma non lo ha visualizzato?
		</li>
		<li>
			Ha senso scrivere un test per un problema da difetto di progettazione di cui l'analista (NcE) non si rende conto?
		</li>
	</ul>
	Sembra essere comunque corretto assegnare anche questa attività ad un NcE. 
	Il computer più potente del mondo, sviluppato da Google e IBM, raggiunge appena il 4.5% delle capacità del cervello umano.
	Quindi prendiamo un super computer biologico e ne riduciamo la capacità al 4,5% per fargli scrivere piccoli programmi, per testare grandi programmi, che cambiano nel tempo.
</p>

<h>
   Complichiamoci la vita
</h>
<p>
   Nel tentativo di semplificare, per amore
   della scoperta e tanti altri motivi ignobili, mi sono complicato la vita.
</p>
<p>
   Cosa c'era di male in:
</p>
<pre>
   <b>function</b> ClientiInsolventi( filtro ) {

      <b>return</b> db($<span class="orange">"SELECT campoA, campoB, campoC FROM tabella WHERE campoD = {filtro}"</span>)

   }
</pre>
<p>
   che è compatibile con il 100% dei db engine compatibili SQL92? Al più si
   mette un <b>IF dbEngine=X THEN ... ELSE ...</b> in funzione del rapporto di
   Pareto. In oltre rispetta i principi DRY e KISS.
</p>
<p>
   Ma anche io ho preferito qualcosa di più <span class="orange">colorato</span> come:
</p>
<pre>
   ClientiInsolventi <b>Insolventi</b> <op>=</op> db
            .<cmd>From</cmd>&lt;<cmd>ClientiInsolventi</cmd>&gt;()
            .<cmd>Where</cmd>(x <op>=></op> x.campoD <op>=</op> filtro)
            .<cmd>Select</cmd>(x <op>=> <b>new</op></b> { x.campoA, x.CampoB, x.CampoC }

   )
</pre>
<p>
   che è compatibile con il semantic check dell'IDE ma difficile da scrivere
   e specifico di uno dei tanti linguaggi general pourpose. Poi comunque
   diviene la SELECT di sopra o non si sa cosa. Nessuno ha ancora
   completato il driver ORM della prossima versione di engine SQL, noSQL, a colonne o
   quella ancora non esiste.
</p>
<p>
	Ovviamente c'è un perché. L'obiettivo è partire da una struttura comune (una <b>CLASS</b>) e da li arrivare a 
	un <b>CREATE TABLE</b> sul server, ad una <b>PROPERTY</b> Data nella <b>FORM</b> sul client, serializzazione->deserializzazione 
	grazie alla reflection e finire con <b>INSERT/UPDATE</b> e ricominciare con SELECT per chiudere il cerchio in modo da preservare l'integrità.
</p>
<p>
	Si poteva fare anche 20 anni fa? Si. Lo si faceva? Si, però bisognava costruire tutti gli script etc. etc. Perché oggi è meglio? 
	Lo vediamo dopo un breve stacchetto publicitario.
</p>
<p>
   <b>Gli ORM come l'OOP danno quel piacere psicologico non verificabile.</b>
</p>
<p>
	Perché dovrebbe esserlo? Per il syntax highlight? Per il semantic check? Perché c'è l'IDE che ci assiste e ci sono linguaggi più IDE oriented?
	Forse si ma allora perché siamo arrivati ad aver bisogno di Jenkins e la sua band che lavorano dietro le quinte come i processi batch di una volta?
</p>
<p>
   Il software è un eco-sistema e se si delega o lo si sporca, finisce prima o poi per congestionarsi.
</p>
<p>
	Ma più stratificazioni vuol dire più flessibilità, più personale, più skills, più soldi dall'help-desk e più+più=meno, al-meno nella testa di qualcuno.
</p>

<h>
   Vedo il tuo bug e rilancio con un deadlock di classi
</h>
<p>
   Qualsiasi linguaggio è un sistema circolare per natura. La "parola" non
   è la "cosa". A parole, tutto può diventare il suo contrario. Non c'è
   astrazione che lo impedisca. Proprio noi italiani siamo maestri
   in questo.
</p>
<p>
   Un'azienda da un servizio tramite i suoi membri che lo danno anche
   privatamente. Solo pensare agli eventuali conflitti, alle conseguenze e
   alla loro gestione è un costo non indifferente che cozzerà anche con il
   sistema di livello superiore (il contenitore).
</p>
<p>
   Tutto parte da un individuo che fa una cosa. Un'altro lo vede e lo
   fa anche lui. Arriva l'osservatore che dice:"Hei, ci sono due entità
   che adottano comportamenti comuni. Facciamone un modello!". Fatto il
   modello, lo si applica in scala e diventa un disastro che sta in piedi
   solo per inerzia.
</p>
<p>
   Non bastano due gambe per tenere in piedi un tavolo
</p>
<p>
   Per rispondere alla richiesta (originata ad un'opinione) di un Duca, i matematici hanno impiegato
   600 anni per dimostrare che non era matematicamente possibile stivare meglio
   le palle di cannone, di come i contadini facevano con le arance. Con più palle di cannone la nave poi sarebbe andata più lenta e quindi bah!
</p>
<p>
   La tridimensionalità è una condizione minima per non
   incappare in errori concettuali. E' una regola che applico
   anche nell'UI design, ma questo è un altra questione.
</p>

<h>
George A. Miller e il magico numero 7+-2
</h>
<p>
	Ho usato questa regola per anni, assieme alla teoria dei sistemi, per raggiungere gli obiettivi nei tempi e costi stimati, senza ritrovarmi grossi problemi in post produzione.
	I programmi come G-Marmo, Tavolinux e SAP Connector che sono sopravvissuti o sopravvivono per otto o più anni senza modifiche, ne sono una testimonianza.
</p>

<h>
Kiss me the code
</h>
<p>
   Il seguente esempio è tratto dal testo "Clean Code". In alto a destra
   c'è il codice d'origine. A sinistra la revisione dell'autore. In basso
   a destra la mia versione.
</p>
<p>
   L'autore spezza il funzioni più piccole, auto-esplicanti. Non tutti i
   linguaggi consentono nested functions. Una classe non avrebbe senso
   (figuriamoci condita di interfaces :-)
</p>
<p>
   La mia versione sembra scritta da un bambino ordinato, ma fa
   di più. Sempre per il principio di Heisemberg, non si può ottimizzare
   sia per tempo che per spazio. Quindi ho usato "più memoria" replicando
   parti di stringa, in violazione del principio DRY. Il codice è più
   compatto, leggibile, capibile dai vecchi come me e dai NcE. Con il
   tempo risparmiato, ho aggiunto l'internazionalizzabilità.
</p>
<p>
   Rimane incasinabile ma lo trovo improbabile. Si fa prima a
   rifare tutto, riciclando questo codice come pseudo-code.
</p>
<p>
   Ho detto di aver violato il principio DRY ma ritengo che, a livello
   strutturale, lo è anche fare più funzioni. La mia
   violazione del DRY preserva il KISS.
</p>
<div style="display:inline-block; width:100%">
   <code style="background-color: #78c1fb; float:left; display: inline-block; vertical-align: top;">
   <b>// "Clean code" (pg. 28,29)</b>

   <b>private</b>
   <b>void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>public</b> string make(
         <b>char</b> candidate, <b>int</b> count
     )
     {
        createPluralDependentMessageParts(count);

        <b>string</b> guessMessage = string.format(
           "There %s %s %s%s",
           verb, number, candidate,
           pluralModifier
           );

        print(guessMessage);
     }

     <b>private
     void</b> createPluralDependentMessageParts(
         <b>int</b> count
     )
     {
        <b>if</b> (count == 0) thereAreNoLetters();
        <b>else if</b> (count == 1) thereIsOneLetter();
        <b>else</b> thereAreManyLetters(count);
     } // createPluralDependentMessageParts

     <b>private
     void</b> thereAreManyLetters(<b>int</b> count)
     {
        number = integer.toString(count);
        verb = "are";
        pluralModifier = "s";
     } // thereAreManyLetters

     <b>private
     void</b> thereIsOneLetter()
     {
        number = "1";
        verb = "is";
        pluralModifier = "";
     }

     <b>private
     void</b> thereAreNoLetters()
     {
        number = "no";
        verb = "are";
        pluralModifier = "s";
     } // thereAreNoLetters

   } // printGuessStatistics
   </code>

   <div style="float:left; display:grid;">

   <code style="background-color: #8bc34a; display: inline-block; vertical-align: top;">
   <b>// the original code</b>

   <b>private
   void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>if</b> (count == 0) {
        
        number = "no";
        verb = "are";
        pluralModifier = "s";

     } <b>if</b> (count == 1) {

        number = "1";
        verb = "is";
        pluralModifier = "";

     } <b>else</b> {

        number = integer.toString(count);;
        verb = "are";
        pluralModifier = "s";

     }

     <b>string</b> guessMessage = string.format(
        "There %s %s %s%s",
        verb, number, candidate,
        pluralModifier
        );

     print(guessMessage);
   }
   </code>

   <code style="background-color: #ffeb3b; display: inline-block; vertical-align: top;">
   <b>// my revision</b>

   <b>void</b> printGuessStatistics( 
      <b>char</b> candidate, 
      <b>int</b> count 
      )
   {
      string msg;

      <b>if</b> (count == 0)
         msg = TR("There are no {0}s",candidate);

      <b>else if</b> (count == 1)
         msg = TR("There is 1 {0}",candidate);

      <b>else if</b> (count > 1)
         msg = TR("There are {0} {1}s", count, candidate);

      print(msg);
   } // printGuessStatistics
   </code>
   </div>
</div>
<h>
	Tributo a Federico Faggin
</h>
<p>
	Dopo un mese, il BASIC già mi stava stretto. Ho così appreso l'assembler Z80 e le fasi di trasformazione di un codice sorgente in binario, o linguaggio macchina.
	Qualche mese fa mio figlio, in prima elementare, mi ha stupito nel saper fare conti complessi e bloccarsi chiedendogli di procedere passo passo togliendo o aggiungendo 1, N volte.
	Ricordo con piacere il registro A dello Z80. A sta per accumulatore. Penso che dovremmo introdurre la programmazione dalla prima elementare come già fanno all'estero.
	Benedetto sia Faggin, padre del processore. Se me ne desse la possibilità lavorerei per lui come Hari Seldom fece per R. Daneel Olivaw.  
</p>
<p>
   Se volete, contattatemi <img src="../images/contact_info_email.jpg"><br><br>
   06.08.2018 Stefano Zaglio
</p>
<pre>
   _______________________________________________________________________

   Fonti bibliografiche
   "Software sytems, failure and success" Pattersons, C.Jones
   "Clean code" Prentice Hall, R.C.Martin
   "Programmazione orientata agli oggetti" Addison Wesley, Brad J.Cox
   "Pragmatic Programmer: From Journeyman to master" Addison Wesley,A.Hunt, D.Thomas
   “Tinycc-devel - mailing list”
   "Da software house a impresa di servizi" Mondadori, M.Bolognani
   "Dai sistemi al pensiero sistemico" FrancoAngeli, P.Mella
   "Oltre la qualità totale" FrancoAngeli, G.Dellacasa, S.Moncini
   "Il principio 80/20. Il segreto per ottenere di più con meno" FrancoAngeli, R.Koch
   "Usiamo la testa" e "Mappe mentali" Frassinelli, Tony Buzan
   "Change" Astrolabio, P.Watzlawick, J.H.Weakland, R.Fish
   "Perchè non possiamo non dirci darwinisti" Rizzoli, E.Boncinelli (2009)
   "Il computer di Dio" e "Il diavolo in cattedra" di Piergiorgio Odifreddi (2000-2003)
   "Verso un'ecologia della mente" Adelphi, G.Bateson (1977)
   “Sviluppare il pensiero nel ritardo mentale” Erickson, P.L. Baldi
   "L'arte di imparare" Mondadori, B.Carey
   [1]Esperienza personale

</pre>
</body>
</html>
