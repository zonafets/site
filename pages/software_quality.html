<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="created" content="2018-08-10609:00:00">
	<meta name="changed" content="2019-11-26T00:17:00">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zaglio CV: Technical culture</title>

	<style>
	  h4 {
			 display:inline-block;
			 position:relative;
			 left:-22%;
			 padding:.2em 1em .2em 22%;
			 border:3px solid #fff;
			 border-left:0;
			 text-align:left;
			 color:#356494;
			 text-shadow:1px 1px 1px rgba(255,255,255,0.6);
			 -moz-border-radius:0 4px 4px 0;
			 -webkit-border-radius:0 4px 4px 0;
			 -khtml-border-radius:0 4px 4px 0;
			 border-radius:0 4px 4px 0;
			 -moz-box-shadow:5px 5px 30px rgba(0,0,0,0.17);
			 -webkit-box-shadow:5px 5px 30px rgba(0,0,0,0.17);
			 box-shadow:5px 5px 30px rgba(0,0,0,0.17);
			 background:-moz-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:-webkit-gradient(linear,left,right,color-stop(0%,#d0dafd),color-stop(100%,#9fb5fe));
			 background:-webkit-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:-o-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:-ms-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:linear-gradient(to right,#d0dafd 0,#9fb5fe 100%);
			 filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d0dafd',endColorstr='#9fb5fe',GradientType=1)
			}
		ul {
			list-style-type: none;
		  }
	  li a {
		position: relative;
		line-height: 1.5em;
		color: #356494;
		text-decoration: none;
		transform: translate(0px); 
		border-color: rgb(165, 182, 200); 
		color: rgb(53, 100, 148);
		border-bottom: 1px solid #a5b6c8;
		}
	  p {
		 text-align: justify;
	  }
	  code {
		 padding:10px;
		 font-family: monospace;
		 display: block;
		 white-space: pre;
	  }
	  .orange {
		color: orange;
	  }
	  cmd {
		color: purple;
	  }
	  op {
		color: red;
	  }
	  com {
		color: green;
	  }
	  
	</style>
</head>
<body style="margin:4px 5% 4px 5%;display:none;">
<project title="COPYRIGHT">
<p>
   Se volete, usare quanto segue, ma citate la fonte.
</p>
</project>

<project title="Premessa">
<p>
	Il lettore perdonerà quel poco di sarcasmo e la forma poco elaborata. 
	Questo documento è un memoriale per autoriflessione, quindi in evoluzione.
</p>	
</project>

<h4>Sommario</h4>
<ul id="summary"></ul>

<project title="Tributo a Alan Turing">
<p>
   A scuola si studia che le idee di Hitler hanno causato una
   guerra di cinque anni e venti milioni di morti. Non si dice però che la
   genialità di uno dei padri dell'informatica ne ha ridotto la durata di due
   anni, salvando quattordici milioni di vite.
</p>
</project>

<project title="L'informatica è una missione sociale">
<p>
   L'informatica è una rivoluzione che non trova eguali nella pietra, nella pergamena e nella carta 
   e nella storia in generale. Le macchine possono pensare, anche se limitatamente ad uno specifico compito.
   Svolgeranno quel compito con diligenza, senza lamentarsene, h24, preservando la stessa sensibilità.
   Ricordiamoci che il cucciolo di animale è operativo in pochi mesi ma non sa pensare ed è difficile da addestrare.
   L'uomo è capace di molto più di un animale e di un computer.
</p>
</project>

<project title="Breve storia dell'informatica">
<p>
	Colossus, Eniac, Edvac, non ricordo bene quale venga prima dell'altro e quale fosse americano e quale inglese.
	Ricordo che quello inglese aveva adottato il sistema binario perché meccanicamente era più facile da costruire e far scalare.
	Del resto ogni problema è scomponibile in sottoproblemi fino alla forma che richiede 2 possibili soluzioni: vero o falso.
	Il mondo non è solo bianco e nero ma la soluzione dei problemi a quanto pare si.
</p>
</project>

<project title="Il principio di indeterminazione di Heisemberg e la programmazione">
<p>
   Heisemberg ha determinato che il valore di una particella e il suo cambiamento non sono
   misurabili contemporaneamente. Anche se questa teoria pare non essere più del tutto vera,
   non possiamo aspettarci di poter predirre il futuro ma solo di pianificarlo al meglio.
</p>
<p>
	Personalmente ritengo che questa vada a braccetto con i teoremi di incompletezza di Gödel. 
	Esso dice che la matematica da sola non basta a descrivere la realtà. 
	Ci vorrà talvolta una descrizione letterale. Probabilmente è per questo che molti credono che la matematica sia un'opinione.
</p><p>
	Tutto ciò, unitamente al difetto intrinseco della circolarità dei sistemi linguistici, ci dice che non esiste un 
	linguaggio di programmazione migliore di un altro. <b>Quindi bisogna cercare e assumere programmatori e non esperti in un linguaggio</b>
</p>
</project>

<project title="80%Basic/20%C">
<p>
   Nel '700 il matematico A.Pareto, stimò che le relazioni tra
   gli elementi di un dominio (non ottimizzato) finiscono in rapporto 
   80/20 (più o meno). Il 20% del prodotto, rende l'80%.
   Nell'80 IBM fece proprio questo principio dichiarando che basta
   scrivere il 20% del codice in un linguaggio a basso livello.
</p>
<p>
   Questo principio si può applicare anche all'organizzazione del codice e non solo al tipo.
   Facile dirsi ma ovviamente tra teoria e pratica, c'è sempre di mezzo l'applicazione pratica.
</p>
</project>

<project title="Evoluzione di Hello World!">
<p><img src="../images/evolution.png"></p>
<p>
	<pre>print <com>"hello!"</com></pre>
	Quanti modi ci sono per scrivere un programma così semplice? Eppure questo programma può essere complicato a piacere.
	Basta cercare i modelli alla base del comando e del contenuto e proseguire allo stesso modo per il risultato. 
	La ricerca del tipo del tipo del tipo etc. ricorda la storia del millepiedi che smise di camminare quando cercò di capire 
	come faceva. Questo non vuol dire che non si debba ricercare più finezza nell'analisi e nello sviluppo ma solo che 
	la ricerca del modello perfetto porta alla perfetta irrealizzazione.
</p>
</project>

<project title="L'astrazione">
<p>
   L'idea di astrarre per meglio concretizzare, è paradossale ma piace psicologicamente.<br>
   Sto scrivendo un memoriale sull'OOP, con dispiacere di chi mi conosce. Ma un assaggio degli effetti dell'astrazione 
   si trovano anche nel paragrafo "jrVSsrVSjr".
</p>
</project>

<project title="jr-VS-sr-VS-jr">
<p>
	Meglio Junior o Senior? Interno o esterno? Un antipatico competente o due simpatici mediocri? Tutti questi possono convivere. 
	Ciò che non sta assieme è il volere il meglio con la minima spesa o, per dirla con saggezza popolare, la botte piena e la moglie ubriaca.
</p>
<p>
	Le teorie dell'apprendimento dicono che servono almeno 3 esperienze dello stesso tipo per afferrare un concetto. 
</p>
<p><img src="../images/curve-learning.png"></p>
<p>
	La curva gialla indica verosimilmenta cosa dovrebbe accadere in condizioni ottimali. 
	La curva viola è riferita ad un senior, che apprende lentamente con ponderatezza per poi partire a razzo, sempre che non gli vengano tarpate le ali. 
	Ovviamente un senior che da 30'anni programma solo in RPG sullo stesso programma, non avrà quell'andatura. 
	La curva arancio è riferita ad un junior che apprende rapidamente per poi stabilizzarsi. Questo accade perché subisce lo stesso tarpamento di ali, perché gli mancano le basi o perché 
	è sovra strutturato da troppa istruzione nozionistica. Vediamo un caso pratico.
</p>
<p><img src="../images/jr-vs-sr-solution.png"></p>
<p>
	E' stato chiesto al giovane sviluppatore del modulo centrale di fornire al client informazioni d'esempio, per sopperire alla latenza dello sviluppo del server. 
</p><p>
	Essendo tale l'inprinting dei suoi docenti o di qualche documento di evangelizzione di una delle case informatiche dominanti, la soluzione è concettualmente corretta.
	L'esecuzione lo è stata formalmente altrettanto. Al lato pratico però, una volta arrivato il server, è diventata sovra-strutturazione d'intralcio per gli immancabili cambiamenti. 
</p><p>
	Nel diagramma di destra c'è la soluzione che avrei proposto io. Avrei riciclato letteralmente, anziché astrattamente, il codice preesistente. 
	La prima soluzione è efficacie. La seconda è efficiente. Quest'ultima è basata sul concetto del LoadBalancing ed è quindi fuori dallo schema concettuale. Irrazionale ma non irragionevole.
</p><p>
	Sono altre poi le osservazioni che si potrebbero fare sulla carenza progettuale l'assenza di retrospettiva.
</p>
</project>

<project title="I commenti del codice">
<p>
   Quante parole spese su questo tema. Certamente abbiamo capito che i giudizi sono da evitare. 
   Non possiamo commentare 2.000.000 di righe di codice. Il codice è per sua natura (di linguaggio) auto-esplicante. 
   Ma i nomi che vengono impiegati possono indurre in errore. Non ha senso chiamare una variabile "FieldIndexOfSourceTable" in un contesto di 10 righe di codice. 
   Basterebbe "i" o "idx" ma i più blasonati manuali fanno venire voglia di programmare in COBOL, anziché scrivere una riga di commento per ogni riga di codice. 
</p>
</project>

<project title="Chiudere la porta">	
<p>
	"Chiudere la porta" è un comando che non esprime il processo. Poiché la mia auto è vecchiotta,
	ho spiegato a moglie e figli di "accompagnarla fino a 10cm dalla chiusura e poi chiuderla". 
	<b>Questo esempio ha delle implicazioni con l'impiego delle risorse, l'importanza della documentazione e il Pair Programming. </b>
</p>
</project>

<project title="Paperless non è informatizzare">
<p>
   L'apporto dell' informatica non comporta lo stesso meccanismo che è servito alla pergamena per sostituire le tavole di pietra 
   e alla carta per sostituire la pergamena.
   Sebbene la digitalizzazione riduca i costi a 1/10, aumentano i costi del processo.
   I software per il lavoro documentale come Word e Excel sono oggi dispersivi e superati dal Web e ancor di più dal cloud.
</p>
</project>

<project title="Gestione del team e della conoscenza">
<p><img src="../images/the-three-logical-levels-of-effectiveness.png"></p>
<p>
	Nella mia lunga esperienza, ho rivestito diversi ruoli in diverse aziende. Sono stato diretto e ho diretto e poi sono stato ancora diretto.
</p><p>
	Grazie a questa multipla e dicotomica esperienza, ho notato che dirigendo si chiede agli altri cervelli di funzionare diversamente da come sono abituati. 
	Questo è già un fattore di inefficienza. 
	Per attuare quest'operazione, bisogna fare formazione diretta o delegarla. Questo pone le risorse in ordine seriale anziché parallelo ed è altro fattore di inefficienza. 
	La formazione non è proprio abitudine italiana. Per praticità poi preferiamo dare informazioni orali senza aspettarci feedback e aggiungiamo altra inefficienza. 
    Scritte o orali che siano, se non si sa scrivere bene, si può dare delle indicazioni intendendo altro. Così si creano facili bersagli e capriespiatori, finendo 
	per perdere le risorse che con tanta difficoltà è stata trasformata in ciò che non era. 
</p><p>
	Ho notato troppo spesso la presenza di gelosia per le informazioni. I motivi erano diversi:
	<ol>
		<li>preservazione della propria importanza</li>
		<li>difficoltà a trovare strumenti agili</li>
		<li>mentalità gestionale di vecchio tipo</li>
	</ol>
	La mentalità ha prodotto leggi moderne che hanno collocato le risorse intellettuali al pari di quelle operative, riducendone il valore. 
	Mentre è relativamente facile che l'operatore acquisisca "la testa" del suo responsabile, ciò è altamente improduttivo per la risorsa intellattuale.
</p><p>
	Questo perché si produrrà un processo di lavoro seriale più che parallelo. Si creeranno poi tutta una serie di ambiguità che, andando a braccetto con la 
	nostra cultura catto-latina del senso di colpa, individuerà facili bersagli e capri espiatori.
</p><p>
	Sbagliando si impara perché ci si approssima alla verità. L'errore vero consiste nel ripetere gli stessi sbagli. Chi cercherà di cambiare lo status quo sarà facile bersaglio.
</p><p>
	Ciò porta al turn-over, con perdità del knowhow e degli sforzi per l'individuazione degli strumenti. Il che agevolerà la preservazione dell'importanza dei soliti.
	Il cerchio si chiude e la storia si ripete fino a quando fattori esterni di enorme portata non produrranno un cambiamento forzato.
</p>
</project>

<project title="Mindmaps">
<p>
Il cervello è il nostro socio. Lui guida l'automobile mentre noi pensiamo ad altro. 
Lui pensa a quello che noi vogliamo dire. Non abbiamo il manuale. Non sappiamo ancora come funziona. 
Sappiamo che se srotolato, occupa la distanza di A/R tra Terra e Luna. 
Sappiamo che il computer più potente del mondo raggiunge il 4.5% della sua potenza.
</p><p>
Il seguente disegno è una mappa spontaneamente prodotta dal mio cervello relativamente ad una situazione. 
Analizzandolo vi trovo un incredibile concentrato di informazioni relative al passato, presente e futuro. 
</p>
<p><img src="../images/mindmap.png"></p>
<p>Se si trovasse il modo di poter creare una simile mappa cooperativamente, le potenzialità di un gruppo di lavoro
aumenterebbero esponenzialmente.
</p>
</project>


<project title="Il pair programming">
<p>
	Funziona. Dicono faccia risparmiare il 30%. Si, nel mondo "organizzato" anglosassone, nel mondo "italiano" latino, arriverà anche al 50%.
</p>
</project>

<project title="Il principio della profezia autorealizzante">	
<p>
	La teoria dei sistemi dice che:
	<ul>
		<li>se capita 1 volta è un caso</li>
		<li>se capita 2 volte è un sospetto</li>
		<li>se capita 3 volte è sistemico</li>
	</ul>
	La psicologia dice che se si ha paura di qualcosa, l'oggetto della paura si materializzerà.<br>
	Le soluzioni possibili sono:
	<ul>
		<li>non aver paura</li>
		<li>prevendire il formarsi delle condizioni dell'oggetto</li>
		<li>avere gli strumenti per gestirla</li>
	</ul>
	Ovviamente bisogna avere le risorse, cioè trovarsi nelle condizioni di poter applicare una delle tre soluzioni.
</p>
</project>

<project title="I principi DRY & KISS">
<p>
   "Do Not Repeat Yourself" e "Keep It Simple And Stupid" sono capi saldi
   della programmazione. C'è chi si spinge oltre con "non commentate il
   codice, riscrivetelo" ossia scrivere codice autoesplicante 
   (poiché è scritto è già tale, forse il riferimento è ad altro). 
   Vedremo degli esempi.
</p>
</project>

<project title="In principio erano i memory leak">
<p>
   Quando la programmazione era solo strutturata e lo sviluppo software
   partiva quasi dal nulla, il <b>programmatore</b> doveva necessariamente <b>sviluppare diligenza</b> e
   chiudere tutto ciò che apriva.
</p>
<p>
   Poi vennero il <b>Garbage Collector e nuovi paradigmi di programmazione
   astratta</b> che ancora oggi promettono al programmatore
   di poter dimenticare tutta una serie di fastidiosi doveri. Il concetto
   dell'OOP nasce da un'idea di Alan Kay che ha dichiarato di non 
   aver mai pensato ad un linguaggio. Il suo
   accostamento alla biologia era solo un'analogia. La biologia
   tratta più di due o tre livelli (classe/istanza o
   modello/classe/interfaccia). Con famiglia, regno e quant'altro ne ha almeno
   nove. Ogni semplificazione implica una riduzione e ogni obbligo è anche un impedimento.
</p>
<p>
   Nel linguaggio delle LEGO, se i mattoncini rappresentano il carattere e la loro combinazione forma la personalità.
   Se funzioni e tipi base sono i mattoncini. Le LEGO moderne sono più bene in quanto più vicine al prodotto rappresentato.
   L'aumento dei micro-pezzettini e la loro specializzazione ha ridotto la creatività. Probabilmente si possono fare anche
   più cose, ma è richiesta maggiore creatività ed immaginazione. Ciò scoraggia l'inventiva.
</p>
</project>

<project title="Come ammazzare un QuadCore con due righe di codice">
<p>
	Quando ho cominciato questo mestiere, le CPU erano a 4Mhz e i computer avevano 16KB di RAM, grafica inclusa.
</p>
<pre>
   S = "", I = 0
   <b>WHILE</b> ( I++ < 5000000 ) <b>DO</b> S = S + "0123456789"
</pre>
<p>
   Questo semplice programma esegue il concatenamento di 10 caratteri
   per 5 milioni di volte. Richiede solo 1/1000 della memoria di cui sono dotati i computer moderni. 
   E' un esempio forzato, ma su un processore a 3GHz, verrebbe eseguito in un millesimo di secondo
   (1/3000000000*5000000).
</p>
<p>
   In pratica arriverà invece a saturare anche un computer potente,
   poiché quella che dovrebbe essere un concatenamento (progressivo) è in
   realtà una somma, ossia un'operazione ripetitiva che si porta dietro il
   pregresso.
</p>
<p>
   Il C++ capisce che la somma è un concatenamento ed ottimizza. C# NON lo faceva, almeno fino alla versione 6.
   Vorrei sapere se Haskell lo fa e come risolve questa situazione.
</p>
<p>
   Chi NON ha esperienza di programmazione a basso livello, potrebbe non
   scoprirlo mai, concludendo che sia necessario scalare l'hardware.
</p>
<p>
	Questo problema affligge maggiormente nell'uso di oggetti e la dove ci sia gestione di memoria con il Garbage Collector.
</p>
</project>

<project title="Polimorfismo">
<p>
   Prima dell'OOP si vedeva codice tipo:
   <pre>
      if action = costante then
      else if action = ...
   </pre>
   Dopo l'OOP si vede codice tipo:
   <pre>
      if typeOf action is ....
   </pre>
</p>
</project>

<project title="GUID per ogni occasione">
<p>
   Vedo spesso usare il GUID come chiave per ovvie ragioni di
   unicità. E' utile soprattutto in previsione di una sincronizzazione tra
   sistemi diversi anche se appartenenti alla stessa soluzione (es.
   mobile<->server). Anche questa è una soluzione psicologicamente di
   comodo. Un INT indirizza quattro miliardi di records ed è più che
   sufficiente.
</p>
<p>
   Quel che un programmatore sa è che un INT occupa 4bytes e un GUID
   16bytes. Può non sapere che un
   processore a 32 ha una word di registro che contiene l'INT ma
   ne deve impiegare 4 per un GUID. Ciò vuol dire che (sempre esempio
   forzato), un processore a 3GHz potrebbe gestire 3 miliardi di ID di tipo INT
   al secondo. Diventano 700 milioni in caso di GUID. Ovviamente sappiamo che già questo numero va ben oltre la realtà.
</p>
</p>
   Le implicazioni sono tante. Ho potuto però dimostrare ai membri del mio
   team che una sincronizzazione PDA/SERVER che mandava in crash il PDA
   con 3000 records con GUID, raggiungeva i 15000 con l'INT. Poi
   abbiamo risolto mandando l'intero archivio, ma non ho detto loro che si
   poteva migliorare di un fattore 10 le prestazioni con un semplice [segreto].
</p>
</project>

<project title="La ricerca è lenta, aggiungiamo un indice">
<p>
   Rimanendo in tema databases, mi è capitato tanto di dover spiegare cosa
   e come aggiungere indici, quanto <b>perché toglierli o fare a meno</b>. Se da
   una parte è abbastanza intuibile che un indice appesantisce la fase di
   scrittura, si pensa meno che una scrittura può implicare una
   lettura. Figuriamoci in ambiente ad alta concorrenza, magari su server monolitico.
</p>
<p>
   Per questioni di scelte progettuali, questo problema può rendere
   addirittura un prodotto gratuito come <b>Postresql più interessante di una
   licenza MSSql</b> Server Enterprise da 150.000€.
</p>
<p>
   Ma <b>quel che sfugge</b> per carenza di knowledge base (KB) è che una lettura
   tramite indice può sfociare certamente in una letura diretta di una pagina, ma questa è come
   <b>sparpagliata in una stanza assieme alle altre</b>. Vediamo la grafica.
</p>
<p>
   La figura 1 è una raffigurazione convenzione di indice a sinistra e tabella a destra.
</p>

   <img src="../images/dbidxtbl.png">  fig.1

<p>
   Nel vecchio dBase, queste due strutture costituivano due
   files. Oggi finiscono in un unico file rappresentabile come in figura 2.
</p>

   <img src="../images/dbsinglefile.png"> fig.2

<p>
   La figura 2 verrebbe utile per far capire perché MSSQL richiede meno
   risorse di Oracle ma allo stesso tempo degrada esponenzialmente in
   performance. Non è questo però l'oggetto del paragrafo.
</p>
<p>
   Questa vista logica, nella realtà diventa qualcosa di simile alla figura 3.
</p>

   <img src="../images/dbdisk.png"> fig.3

<p>
   Ricordo che sono delle rappresentazioni forzate. Lo sparpagliamento può essere minore,
   grazie alle proprietà del file system o alle capacità del sistema
   operativo ma può essere anche maggiore a seconda della configurazione
   software o hardware. Quando non sono HP e Oracle a lavorare assieme, 
   spesso le configurazioni software e hardware non c'entrano nulla l'una con l'altra.
</p>
<p>
   Questo vale sia per SQL che noSQL. Già qualche
   sostenitore del noSQL si sta ricredendo. Ne ho visti tanti di entusiasmi smorzarsi dopo il primo decennio.
   Se ci sono più di 800 linguaggi di programmazione ma il C rimane tra i primi 10 più usati, ci sarà un motivo.
   Mi stupisce sempre sentire di performance eccelse di strumenti quali ad esempio Node.js.
   Azzarderei a dire che le performance di sviluppo sono inversamente proporzionali alle prestazioni di runtime.
</p>
<p>
   <b>Per un'analisi di differenza di normalizzazione in caso di un Document System Management, 
   seguire questo <a href="dsm_normalization.html">link</a></b>
</p>
</project>

<project title="10 piccole query">
<p>
	10 piccole query su mono processo possono essere più veloci di una query complessa ottimizzata in automatico dall'engine su CPU multithread.
</p>
</project>

<project title="DRY e normalizzazione">
<p>
	La seguente immagine rappresenta la classica scelta di relazione 1 a MOLTI per la gestione di un software 
	documentale. Un record è legato a molti documenti. Ogni documento ha delle proprietà.
</p>
   <p><img src="../images/dms-normalization-1.png"></p>
<p>
	La rappresentazione di questa struttura pone però i documenti in linea con il relativo record. 
	Quindi se la verticalizzazione consente l'associazione di un numero infinito di documenti, nella pratica 
	il numero impiegato è limitato.
</p><p>
	La seguente struttura sacrifica il principio di normalizzazione in nome di un uso pratico, ccontenuto,
	non limitato, più performante e flessibile.
</p>
   <p><img src="../images/dms-normalization-2.png"></p>
</project>

<project title="XLS">
<p>
<pre>"L'organizzazione di un'azienda è inversamente proporzionale al numero di fogli XLS che usa."</pre>
Questa non è mia, ma la sottoscrivo. Se già rigide strutture possono contenere dati assurdi tramite campi sovradimensionati o note, 
figuriamoci cosa può fare una cella Excel che può cambiare natura. Sfortunatamente in un periodo in cui molti individui
sono quantitativamente troppo istruiti, dimentichiamo che una piccola differenza di qualità fa una grande differenza nel lungo periodo.
</p><p>
Una soluzione "smart" può sembrare frutto di genialità e creatività, ma potrebbe solo gestire il problema senza risolverlo.
</p>
</project>

<project title="Ho visto cose che voi umani...">
<pre>
   <b>TRY</b>

         VARIABILE = ALTRA_VARIABILE

   <b>END TRY</b>
</pre>
<p>
   Abbiamo visto tutti almeno una volta usare eccezioni a modo di:
   "Chissenefrega, basta che non si spacchi che puoi vendere bugs come
   fossero features":
</p>
<p>
   <b>Ho visto</b> programmi C++ che facevano un uso raffinato dei templates
   (AGG). Al momento di usarli ho lasciato perdere. Troppo complessi. Poi mi sono accorto anche che quando il gioco si fa
   duro, solo l'hardware può giocare e non c'è ottimizzazione software che possa competere.
</p>
<p>
   <b>Ho visto</b> programmi fare uso di interface in maniera magistrale, in un
   potpourri di codice auto esplicante. Poi è arrivato il <b>neolaureato con
   esperienza</b>. Il <b>NcE</b> esiste per convenzione del 60% degli annunci di ricerca italiani.
   In barba ad Heisemberg viene assunto da selezionatori Nce. 
   Naturalmente c'è un referente che sa tutto ma non
   dice niente e non ha mai avuto il tempo di scrivere l'ABC. 
   Altro che metodo Toyota o principio 80/20. Tra teoria e pratica non c'è nient'altro che un muro.
</p>
<p>
   Fresco di tutte le sante neo teorie accademiche, il nostro NcE guarda il problema diritto negli occhi e capisce che ha
   bisogno di weaponX(). Funzione, classe o metodo che sia, la implementa.
   Un colpo al cerchio e uno alla botte e va che è un piacere.
   Quando diventa esperto anche dell'applicazione, scopre che esisteva già
   e si chiamava weapon_YX(). Ormai è tardi per riscrivere il codice
   perché c'è un nuovo problema all'orizzonte o addirittura un nuovo
   lavoro. Così il nuovo NcE wrappa weaponX su weapon_YX giusto per
   mettere un poco di ordine senza sconvolgere. Poi arriva il nuovo-nuovo NcE.
</p>
<p>
   <b>Ho visto</b> usare prefissi "XXX_","AAA_" e altro alle tabelle temporanee dove avevo imposto il prefisso TMP. Alla fine
   l'azienda ha preferito fare a meno di me e investire il ricavato in altri apprendisti. 
   Tutto questo mentre stavo sviluppando triggers DDL che istruissero gli apprendisti all'uso corretto di nomi e commenti, 
   senza perdere tempo a scrivere documentazione che nessuno legge o gli viene dato il tempo per farlo.
</p>
<p>
   <b>Ho visto</b> banali <span class="orange">"SELECT qualcosa FROM tabella WHERE condizione"</span>
   seppellite sotto strati e strati di codice da far piangere (è la nuova programmazione a cipolla),
   10 passaggi, alcuni ricorsivi, di 30 istruzioni, equivalenti ad 1 passaggio di 10 istruzioni SQL92. 
</p>
<p>
	<b>Ho visto</b> professionisti(che di fatto sono solo lavoratori autonomi) scrivere codice inutilmente suvrastrutturato, 
	perché erano abituati così e quindi per loro era più facile e veloce.
</p>
<p>
	<b>Ho visto</b> utenti dichiarare che il programma aveva dato errore X ma senza visualizzare il messaggio.
</p>
<p>
	<b>Ho visto</b> tanti workaround di difetti di progettazione produrre qualcosa tipo un jumbo con i freni di una bicicletta.
</p>
<p>
	<img src="../images/pyramid-boxes.jpg"><img src="../images/colour-boxes.jpg">
</p>
<p>
   <b>Ho lavorato</b> alla manutenzione di 2.000.000 di righe di codice scritto con tutti i crismi OO e dei patterns & C.. e mi sono chiesto se 
   sia più facile cercare una scatola tra 4.000.000 disposte in piano ad array, 
   oppure una in 2.000.000 disposte a piramide, che per di più contiene solo un riferimento astratto alla vera scatola.
</p>
<p>
	<b>Ho inseguito</b> oggetti dentro metodi annidati che ritornavano un oggetto <b>result</b>. Messi in fila farebbero:
	<pre>
		Return(Return(Return(Return(Return(Return(Return(object)))))))
	</pre>
	Poi ho dovuto fare una modifica al 4° livello. Questa richiedeva il risultato per sapere se andare oltre.
	Si, lo so, non si capisce. Immaginate di essere al 4° piano di un edificio e di dover salire all'ultimo per sapere se potere proseguire oltre il 4°.
</p>
</project>

<project title="Jenkins e gli Hyper Tests">   
<p>
   Per quanto sopra (frammentazione del codice o mal progettazione) e per questioni di
   sicurezza (con tutta la gente che si assume e se ne va), 
   si sono resi necessari i sistemi automatizzati di
   compilazione e test. Proprio come facevo 25 anni fa quando programmavo in C, anche se ero da solo.
</p>
<p>
   A quel tempo le grosse applicazioni si dividevano verticalmente in
   librerie e orizzontalmente in chunks di funzioni. Oggi ci sono i
   namespaces e le classi ma dobbiamo mettere i progetti nei posti sbagliati
   solo perché le soluzioni non prevedono links simbolici.
</p>
<p>
	Testare è una scienza o un'arte? Mi chiedo questo perché la scienza sa di non sapere ciò che a volte i tests presuppongono di conoscere. 
	<ul>
		<li>
			Quanto costa, testare le differenze di rappresentazione tra Firefox e Chrome?
		</li>
		<li>
			Come fare a testare una procedura basata su un input casuale dell'utente?
		</li>
		<li>
			Ha senso fare un test su una funzione deterministica? O una funzione tipo ADD(X,Y)?
		</li>
		<li>
			Come fare a testare la mancanza di formazione nell'utente che dice che il programma non va perché manca la carta nella stampante?
		</li>
		<li>
			E quando l'utente dice che il programma è andato in errore ma non lo ha visualizzato?
		</li>
		<li>
			Ha senso scrivere un test per un problema da difetto di progettazione di cui l'analista (NcE) non si rende conto?
		</li>
	</ul>
	Sembra essere comunque corretto assegnare anche questa attività ad un NcE. 
	Il computer più potente del mondo, sviluppato da Google e IBM, raggiunge appena il 4.5% delle capacità del cervello umano.
	Quindi prendiamo un super computer biologico e ne riduciamo la capacità al 4,5% per fargli scrivere piccoli programmi, per testare grandi programmi, che cambiano nel tempo.
</p>
</project>

<project title="Complichiamoci la vita">
<p>
   Nel tentativo di semplificare, per amore
   della scoperta e tanti altri motivi ignobili, mi sono complicato la vita.
</p>
<p>
   Cosa c'era di male in:
</p>
<pre>
   <b>function</b> ClientiInsolventi( filtro ) {

      <b>return</b> db($<span class="orange">"SELECT campoA, campoB, campoC FROM tabella WHERE campoD = {filtro}"</span>)

   }
</pre>
<p>
   E' compatibile con il 100% dei db engine compatibili SQL92. Al più si
   mette un <b>IF dbEngine=X THEN ... ELSE ...</b> in funzione del rapporto di
   Pareto. In oltre rispetta i principi DRY e KISS.
</p>
<p>
   Ma anche io ho preferito qualcosa di più <span class="orange">colorato</span> come:
</p>
<pre>
   ClientiInsolventi <b>Insolventi</b> <op>=</op> db
            .<cmd>From</cmd>&lt;<cmd>ClientiInsolventi</cmd>&gt;()
            .<cmd>Where</cmd>(x <op>=></op> x.campoD <op>=</op> filtro)
            .<cmd>Select</cmd>(x <op>=> <b>new</op></b> { x.campoA, x.CampoB, x.CampoC }

   )
</pre>
<p>
   E' compatibile con il semantic check dell'IDE, difficile da scrivere,
   specifico di uno dei tanti linguaggi general pourpose. Comunque
   diverrà SQL non ottimizzato o non si sa cosa, poiché nessuno ha ancora
   completato il driver ORM per la prossima versione di engine SQL, noSQL, a colonne o
   l'engine che deve ancora venire.
</p>
<p>
	Ovviamente c'è un buon perché. L'obiettivo è l'integrità strutturale e semantica, 
	partendo da una struttura comune (una <b>CLASS</b>) per arrivare in automatico a 
	un <b>CREATE TABLE</b> sul server, ad una <b>PROPERTY</b> Data nella <b>FORM</b> sul client, serializzazione->deserializzazione 
	(automatica grazie alla reflection) e finire con <b>INSERT/UPDATE</b>, per ricominciare con SELECT e chiudere il cerchio.
	Questa pratica deve diramarsi ovunque, anche su cliente web e quindi JSON e Javascript. 
	Ci stiamo arrivando con transpilazione C#/Javascript assieme al webASM, che promette migliori performance.
</p>
<p>
   Serve? Beh poco nei casi in cui l'applicazione consente all'utente di crearsi le strutture dati, tipo i sw documentali.
   Considerando poi che si tende a voler dare strumenti visuali per evitare di far scrivere codice.
   Nulla vieta di generarlo. Insomma, altri dilemmi.
</p>  
<p>
	Si poteva fare anche 20 anni fa? Si. Lo si faceva? Si, perché i programmatori sapevano fare quel che oggi fa l'IDE. Magari si partiva dalla TABLE per ottenere la CLASS e le costanti per i riferimenti.
</p>
<p>
   <b>Gli ORM riducono l'engine a semplice repository intercambiabile e questo da il piacere psicologico della facile scalabilità. 
   Poi non implementano l'atomicità, l'integrità, i trigger DDL e quant'altro maturato in 20 anni di evoluzione, ma ci piace la scalabilità.</b>
</p>
<p>
	Soluzione che sia, in coda partono Jenkins e la sua band che lavorano dietro le quinte, proprio come i vecchi processi batch.
</p>
<p>
   Il software è un eco-sistema. Non si comporta come una ruota di pietra quadrata che a furia di girare si smussa e rivela l'efficacia della rotondità.
</p>
<p>
   Comunque anche la raccolta differenziata insegna che la distribuzione fa risparmiare più della centralizzazione. 
   Basta mettersi d'impegno e fare i conti precisi alla quarta cifra decimale per evitare l'effetto farfalla di Lorenz.
</p>
</project>


<project title="George A. Miller e il magico numero 7+-2">
<p>
	Ho usato questa regola per anni, assieme alla teoria dei sistemi, per raggiungere gli obiettivi nei tempi e costi stimati, senza ritrovarmi grossi problemi in post produzione.
	I programmi come G-Marmo, Tavolinux e SAP Connector che sono sopravvissuti o sopravvivono per otto o più anni senza modifiche, ne sono una testimonianza.
</p>
</project>


<project title="Kiss me the code">
<p>
   Il seguente esempio è tratto dal testo "Clean Code". In alto a destra
   c'è il codice d'origine. A sinistra la revisione dell'autore. In basso
   a destra la mia versione.
</p>
<p>
   L'autore spezza il funzioni più piccole, auto-esplicanti. Non tutti i
   linguaggi consentono nested functions. Una classe non avrebbe senso
   (figuriamoci condita di interfaces :-)
</p>
<p>
   La mia versione sembra scritta da un bambino ordinato, ma fa
   di più. Sempre per il principio di Heisemberg, non si può ottimizzare
   sia per tempo che per spazio. Quindi ho usato "più memoria" replicando
   parti di stringa, in violazione del principio DRY. Il codice è più
   compatto, leggibile, capibile dai vecchi come me e dai NcE. Con il
   tempo risparmiato, ho aggiunto l'internazionalizzabilità.
</p>
<p>
   Rimane incasinabile ma lo trovo improbabile. Si fa prima a
   rifare tutto, riciclando questo codice come pseudo-code.
</p>
<p>
   Ho detto di aver violato il principio DRY ma ritengo che, a livello
   strutturale, lo è anche fare più funzioni. La mia
   violazione del DRY preserva il KISS.
</p>
<div style="display:inline-block; width:100%">
   <code style="background-color: #78c1fb; float:left; display: inline-block; vertical-align: top;">
   <b>// "Clean code" (pg. 28,29)</b>

   <b>private</b>
   <b>void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>public</b> string make(
         <b>char</b> candidate, <b>int</b> count
     )
     {
        createPluralDependentMessageParts(count);

        <b>string</b> guessMessage = string.format(
           "There %s %s %s%s",
           verb, number, candidate,
           pluralModifier
           );

        print(guessMessage);
     }

     <b>private
     void</b> createPluralDependentMessageParts(
         <b>int</b> count
     )
     {
        <b>if</b> (count == 0) thereAreNoLetters();
        <b>else if</b> (count == 1) thereIsOneLetter();
        <b>else</b> thereAreManyLetters(count);
     } // createPluralDependentMessageParts

     <b>private
     void</b> thereAreManyLetters(<b>int</b> count)
     {
        number = integer.toString(count);
        verb = "are";
        pluralModifier = "s";
     } // thereAreManyLetters

     <b>private
     void</b> thereIsOneLetter()
     {
        number = "1";
        verb = "is";
        pluralModifier = "";
     }

     <b>private
     void</b> thereAreNoLetters()
     {
        number = "no";
        verb = "are";
        pluralModifier = "s";
     } // thereAreNoLetters

   } // printGuessStatistics
   </code>

   <div style="float:left; display:grid;">

   <code style="background-color: #8bc34a; display: inline-block; vertical-align: top;">
   <b>// the original code</b>

   <b>private
   void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>if</b> (count == 0) {
        
        number = "no";
        verb = "are";
        pluralModifier = "s";

     } <b>if</b> (count == 1) {

        number = "1";
        verb = "is";
        pluralModifier = "";

     } <b>else</b> {

        number = integer.toString(count);;
        verb = "are";
        pluralModifier = "s";

     }

     <b>string</b> guessMessage = string.format(
        "There %s %s %s%s",
        verb, number, candidate,
        pluralModifier
        );

     print(guessMessage);
   }
   </code>

   <code style="background-color: #ffeb3b; display: inline-block; vertical-align: top;">
   <b>// my revision</b>

   <b>void</b> printGuessStatistics( 
      <b>char</b> candidate, 
      <b>int</b> count 
      )
   {
      string msg;

      <b>if</b> (count == 0)
         msg = TR("There are no {0}s",candidate);

      <b>else if</b> (count == 1)
         msg = TR("There is 1 {0}",candidate);

      <b>else if</b> (count > 1)
         msg = TR("There are {0} {1}s", count, candidate);

      print(msg);
   } // printGuessStatistics
   </code>
   </div>
</div>
</project>


<project title="Tributo a Federico Faggin">
<p>
	Ho iniziato a 13 anni da autodidatta. Non sono un genio, è solo passione. Dopo un mese, 
	il BASIC già mi stava stretto. Ho così appreso l'assembler Z80 e le fasi di trasformazione di un codice sorgente in binario, o linguaggio macchina.
	Qualche mese fa mio figlio, in prima elementare, mi ha stupito nel saper fare conti complessi ma si bloccava chiedendogli di procedere passo passo, togliendo o aggiungendo 1, N volte.
	Ricordo con piacere il registro A dello Z80. A sta per accumulatore. Penso che dovremmo introdurre la programmazione dalla prima elementare come già fanno all'estero.
	Benedetto sia Faggin, padre del processore. Se me ne desse la possibilità lavorerei per lui come Hari Seldom fece per R. Daneel Olivaw.  
</p>
</project>

<project title="La macchina (universale) di Turing">
<p>Leggendo il libro slla storia di Turing, capisco che la famosa macchina di Turing è qualcosa che va oltre la mia umile immaginazione. 
Mi limiterò a ricordarne l'aspetto tecnico-pratico. 
Sostanzialmente questa prende ad uno ad uno una serie di codici che rappresentano nomi, valori e operazioni.  
Queste assegnano i valori ai nomi e operano dei confronti. Sulla base del risultato, si può assegnare un valore ad un nome speciale,
il Contatore di Programma. Questo indica il punto successivo in cui la serie deve proseguire. Con ciò si ottiene una macchina universale.</p>
</project>

<project title="MVVM o MVC o Component?">

<p>Classico esempio:</p>
<pre>
	vm = {
		fname,lname: string
		fullname => fname + ' ' + lname
	}
</pre>
<p>Supponiamo di voler legare l'attivazione di lname alla valorizzazione di fname.
Il legame non è più tra i membri del modello ma esce ed entra nel modello grafico, che è ciò che avviene automaticamente tra fullname e il suo controllo.</p>
<pre>
	fname.subscribe(
		f(value) {
			controlOf(lname).disabled = (value == "")
		}
	}
</pre>
<p>Altrimenti sarebbe stato:</p>
<pre>
	controlOf(fname).onCHANGE = f() {
		controlOf(lname).disabled = ( controlOf(fname).value == "" )
	}
</pre>
<p>Quale'è la differenza?
Che il primo è legato allo stato, il secondo all'evento.
Il primo caso, oltre a richiedere meno codice, funziona anche con:</p>
<pre>
	fname = ""
</pre>
<p>Mentre:</p>
<pre>
	controlOf(fname).value = ""
</pre>
<p>Non fa scattare l'evento keyPRESS a cui potrebbe essere legato l'onCHANGE.</p>
<!--
https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle
https://stackoverflow.com/questions/36950582/angular2-mvc-mvvm-or-mv
https://medium.com/javascript-scene/angular-2-vs-react-the-ultimate-dance-off-60e7dfbc379c
-->
</p>
</project>

<project title="Notazione ungara">
<p>
Oggi la n.u. non ha più senso perché gli IDE ci aiutano ad identificare il tipo di identificatore.
In realtà forse non l'ha mai avuta perché le capacità mentali dei più sono limitate e il problema va necessariamente diviso in sottocontesti piccoli a sufficienza da consentire di chiamare le variabili i,k e n.<br>
Eppure c'è chi ancora la usa quasi come se nella sua testa si parlasse in terza persona:"Lei adesso si trova in una variabile di tipo Classe" e quindi abbiamo "clsVar = new Class;".
</p>
</project>

<p>
   06.08.2018 Stefano Zaglio
</p>
<pre>
   _______________________________________________________________________

   Fonti bibliografiche
   "Software sytems, failure and success" Pattersons, C.Jones
   "Clean code" Prentice Hall, R.C.Martin
   "Programmazione orientata agli oggetti" Addison Wesley, Brad J.Cox
   "Pragmatic Programmer: From Journeyman to master" Addison Wesley,A.Hunt, D.Thomas
   “Tinycc-devel - mailing list”
   "Da software house a impresa di servizi" Mondadori, M.Bolognani
   "Dai sistemi al pensiero sistemico" FrancoAngeli, P.Mella
   "Oltre la qualità totale" FrancoAngeli, G.Dellacasa, S.Moncini
   "Il principio 80/20. Il segreto per ottenere di più con meno" FrancoAngeli, R.Koch
   "Usiamo la testa" e "Mappe mentali" Frassinelli, Tony Buzan
   "Change" Astrolabio, P.Watzlawick, J.H.Weakland, R.Fish
   "Perchè non possiamo non dirci darwinisti" Rizzoli, E.Boncinelli (2009)
   "Il computer di Dio" e "Il diavolo in cattedra" di Piergiorgio Odifreddi (2000-2003)
   "Verso un'ecologia della mente" Adelphi, G.Bateson (1977)
   “Sviluppare il pensiero nel ritardo mentale” Erickson, P.L. Baldi
   "L'arte di imparare" Mondadori, B.Carey
   [1]Esperienza personale

</pre>
</body>

<script>
	// add headers and summary, then show everything
	var summary = document.querySelector("#summary")
	var projects = document.querySelectorAll("project")
	projects.forEach(function(it){
		var h4 = document.createElement("H4")
		var bookmark = document.createElement("A")
		var title = it.attributes.title.value
		bookmark.name = title
		bookmark.innerText = title
		h4.appendChild(bookmark)
		it.prepend(h4)
		var li = document.createElement("LI")
		bookmark = document.createElement("A")
		bookmark.href="#"+title
		bookmark.innerText = title
		li.appendChild(bookmark)
		summary.appendChild(li)
	})
	document.body.style.display="block"
</script>

</html>
