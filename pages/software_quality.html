<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="created" content="2018-08-10609:00:00">
	<meta name="changed" content="2019-11-26T00:17:00">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zaglio CV: Technical culture</title>

	<style>
	  h4 {
			 display:inline-block;
			 position:relative;
			 left:-22%;
			 padding:.2em 1em .2em 22%;
			 border:3px solid #fff;
			 border-left:0;
			 text-align:left;
			 color:#356494;
			 text-shadow:1px 1px 1px rgba(255,255,255,0.6);
			 -moz-border-radius:0 4px 4px 0;
			 -webkit-border-radius:0 4px 4px 0;
			 -khtml-border-radius:0 4px 4px 0;
			 border-radius:0 4px 4px 0;
			 -moz-box-shadow:5px 5px 30px rgba(0,0,0,0.17);
			 -webkit-box-shadow:5px 5px 30px rgba(0,0,0,0.17);
			 box-shadow:5px 5px 30px rgba(0,0,0,0.17);
			 background:-moz-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:-webkit-gradient(linear,left,right,color-stop(0%,#d0dafd),color-stop(100%,#9fb5fe));
			 background:-webkit-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:-o-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:-ms-linear-gradient(left,#d0dafd 0,#9fb5fe 100%);
			 background:linear-gradient(to right,#d0dafd 0,#9fb5fe 100%);
			 filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d0dafd',endColorstr='#9fb5fe',GradientType=1)
			}
		ul {
			list-style-type: none;
		  }
	  li a {
		position: relative;
		line-height: 1.5em;
		color: #356494;
		text-decoration: none;
		transform: translate(0px); 
		border-color: rgb(165, 182, 200); 
		color: rgb(53, 100, 148);
		border-bottom: 1px solid #a5b6c8;
		}
	  p {
		 text-align: justify;
	  }
	  code {
		 padding:10px;
		 font-family: monospace;
		 display: block;
		 white-space: pre;
	  }
	  .orange {
		color: orange;
	  }
	  cmd {
		color: purple;
	  }
	  op {
		color: red;
	  }
	  com {
		color: green;
	  }
	  
	</style>
</head>
<body style="margin:4px 5% 4px 5%;display:none;">
<project title="COPYRIGHT">
<p>
   Se volete usare quanto segue, lo fate a rischio di
   incartamento. Altrimenti citate la fonte.
</p>
</project>

<project title="Premessa">
<p>
	Il lettore perdonerà, spero, quel poco di sarcasmo e la forma poco chiara. 
	Questo documento è ancora in evoluzione in quanto rappresenta sia un memoriale che un memorandum.
</p>	
</project>

<h4>Sommario</h4>
<ul id="summary"></ul>

<project title="Tributo a Alan Turing">
<p>
   A scuola si studia che le idee di Hitler hanno causato una
   guerra di cinque anni e venti milioni di morti. Non si dice però che la
   genialità di uno dei padri dell'informatica ne ha ridotto la durata di due
   anni, salvando quattordici milioni di vite, tra cui probabilmente il
   nostro avo.
</p>
</project>

<project title="L'evoluzione della civiltà">
<p>
   L'informatica è una rivoluzione che non trova eguali nella pietra, nella pergamenta e nella carta.
   Gli informatici hanno una missione sociale.
   La storia non ci aiuta, a parte che sta diventando una babele di linguaggi e di cloni.
</p>
</project>

<project title="E=MC^2">
<p>
	Ecco, ora che sappiamo la formula della relatività speciale, siamo tutti "in-formati".
	Invece, quella formula è una semplificazione.
	Noi informatici non dovremmo farci abbagliare troppo facilmente dall'ultimo articolo di giornale che parla dell'ultimo silver bullet,
	la soluzione delle soluzioni. Nulla si crea e nulla si distrugge. 
</p>
</project>

<project title="Il principio di indeterminazione di Heisemberg">
<p>
   Quando non possiamo provare o negare qualcosa, si crea una credenza basata sul piacere psicologico che più l'attrae.
<p>
   Heisemberg ha determinato che il valore di qualcosa e il suo cambiamento non sono
   misurabili contemporaneamente. 
</p>
<p>
	Ciò vale anche per la comprensione, soprattutto per il difetto della circolarità dei sistemi linguistici.
</p>
<p>
	Personalmente ritengo che questa vada a braccetto con i teoremi di incompletezza di Gödel. 
	Sostanzialmente essi dicono che la matematica da sola non basta a descrivere la realtà. 
	Ci vorrà talvolta una descrizione letterale. Probabilmente è per questo che molti credono che la matematica sia un'opinione.
	Altri credono che la realtà sia una convinzione collettiva.
</p>
</project>

<project title="80%Basic/20%C">
<p>
   Nel '700 il matematico A.Pareto, stimò che le relazioni tra
   gli elementi di un dominio (non ottimizzato) finiscono in rapporto 
   80/20 (più o meno). Il 20% del prodotto, rende l'80%.
   Nell'80 IBM fece proprio questo principio dichiarando che basta
   scrivere il 20% del codice in un linguaggio a basso livello.
</p>
<p>
   Questo principio si può applicare anche all'organizzazione del codice e non solo al tipo.
   Facile dirsi ma ovviamente tra teoria e pratica, c'è sempre di mezzo l'applicazione pratica.
</p>
</project>

<project title="Evoluzione di Hello World!">
<p><img src="../images/evolution.png"></p>
<p>
	<ul>
	<li><pre>print(<com>"hello!"</com>)</pre></li>
	<li><pre><b>const</b> greeting = <com>"hello!"</com>;<br>print(greeting)</pre></li>
	<li><pre><b>var</b> dynamicGreeting <op>=</op> get(greeting);<br>print(dynamicGreeting)</pre></li>
	<li><pre>console<op>.</op>print( dynamicGreeting )</pre></li>
	<li><pre>greetingType dynamicGreeting( greeting);<br>console<op>.</op>print( dynamicGreeting<op>.</op>get() )</pre></li>
	<li><pre>greetingType dynamicGreeting( greetings<op>.</op>hello );<br>console<op>.</op>print( dynamicGreeting.verb )</pre></li>
	<li><pre>greetingType dynamicGreeting( greetings<op>.</op>hello, console );<br>dynamicGreeting<op>.</op>say()</pre></li>
	<li><pre>print(<com>"hello Dr. Falken!"</com>)</pre></li>
	</ul>
</p>
</project>

<project title="L'astrazione">
<p>
   L'OOP (nata negli USA) ha diffuso l'idea che l'astrazione sia la madre delle soluzioni.
   Sfortunatamente ne sappiamo tutti poco, tutt'al più conosciamo qualcuno che sa (il docente o l'articolo che ci hanno istruito).
   La pratica ci ha dimostrato che l'astrazione non ha ridotto l'entropia del software come il type strict non riduce significativamente i bugs. 
   Alla quarta review, un sistema di classi subisce uno sconvolgimento. Si salvano quelle più simili a dei tipi base.
   Infatti la programmazione <b>Object Based</b> non è da eludere.
   Ma ogni linguaggio di programmazione è pur sempre un linguaggio e per questo gravido degli stessi limiti.
</p>
<p>
	Uno di questi è la circolarità. Possiamo infatti definire una variabile <b>white</b> di tipo <b>Color</b> e assegnarle valore <b>black</b>.
	Non è invece possibile creare una variabile di nome <b>True</b> e assegnarle valore <b>False</b> (forse in smalltalk si può anche questo).
	Se con la programmazione strutturata si poteva incappare nello spaghetti code, con l'OOP abbiamo il cipolla code. 
</p>
</project>

<project title="I commenti del codice">
<p>
   Quante parole spese su questo tema. Certamente abbiamo capito che i giudizi sono da evitare. 
   Si vuole un codice autoesplicante, chiamando anche le vecchie variabili "i" dei piccoli contesti con "FieldIndexOfSourceTable".
   Eppure nessuno spiega come commentare codice da 2.000.000 di righe.
   Si potrebbe cominciare considerando il 20% e ... (chiamatemi).
</p>
</project>

<project title="Chiudere la porta">	
<p>
	"Chiudere la porta" è un comando che non esprime il processo. Poiché la mia auto è vecchiotta,
	ho spiegato a moglie e figli di "accompagnarla fino a 10cm dalla chiusura e poi chiuderla". 
	<b>Questo esempio ha delle implicazioni con l'impiego delle risorse, l'importanza della documentazione e il Pair Programming. </b>
</p>
</project>

<project title="Paperless non è informatizzare">
<p>
   Il significato della parola "informatica" non è:"togliamo la carta", come è accaduto con pergamene e tavole di pietra.
   Sebbene paperless riduca i costi a 1/10, aumentano i costi del processo.
   I software di simulazione documentale come Word e Excel e le emails rappresentano un limite che il web supera.
</p>
</project>

<project title="Il pair programming">
<p>
	Funziona. Dicono faccia risparmiare il 30%. Si, nel mondo "organizzato" anglosassone, nel mondo "italiano" latino, arriverà anche al 50%.
</p>
</project>

<project title="Parliamo del sesso degli angeli">
<p>
	Come dicevo dell'OOP, parlare di "albero", "casa" è come parlare del sesso degli angeli. Non ha nulla di concreto.
   Per altro, sempre di comunicazione si tratta, con tutti i vincoli. Tra questi c'è il problema del sesto livello di narrazione.
   A questo livello, qualsiasi contenuto avesse l'origine, sarà completamente cambiato (n.d.p.: Angular già alla seconda versione).
	Avere un disegno comune vuol dire avere un riferimento anche se (o perché) non è chiaro che senso dare alla freccia per rappresentare "A dipende da B".    
</p>
</project>

<project title="Bugs e comunicazione: tutti i bugs sono implementazioni">
<p>
   Se non ci sono dubbi che "2+2=4", già ci vengono con:"4=2+2". Il primo dice che "causa->effetto". Non so gli arabi, ma per chi è abituato a leggere da sinistra a destra, questo è il processo che svolgerà il cervello in automatico.
</p><p>
   Il testo di un bug, redatto da un ex "tecnicamente competente" programmatore, si strutturava così:<br>
   1. contesto del problema<br>
   2. esempio di soluzione temporanea adottata<br>
   3. nota tecnica di implementazione<br>
   4. nota tecnica di altra implementazione analoga<br>
   Il risultato è stato che, pure per un "esperto" come me, ho implementato i punti 2 e 4. Questo perché, voi per fretta, vuoi per sonnolenza, vuoi qualsiasi lecito motivo, ma non certo la volontà di creare danno o extra lavoro, il punto 2 era una ridondanza del punto 3.<br>
   Un'implementazione non ne dovrebbe includere due e chiamarsi bug, ma mi adeguo.<br>
   I bugs sono:"Non ho avuto/dedicato abbastanza tempo all'analisi/test". Meno tempo significa soldi non spesi. Poi ci può essere chi per esperienza, evita a priori di scrivere codice "aperto" alla nascita di bugs, ma questa è un'altra storia. 
</p>
</project>

<project title="Il principio della profezia autorealizzante">	
<p>
	La teoria dei sistemi dice che:
	<ul>
		<li>se capita 1 volta è un caso</li>
		<li>se capita 2 volte è un sospetto</li>
		<li>se capita 3 volte è sistemico</li>
	</ul>
	La psicologia dice che se si ha paura di qualcosa, l'oggetto della paura si materializzerà.<br>
	Le soluzioni possibili sono:
	<ul>
		<li>non aver paura</li>
		<li>prevendire il formarsi delle condizioni dell'oggetto</li>
		<li>avere gli strumenti per gestirla</li>
	</ul>
	Ovviamente bisogna avere le risorse, cioè trovarsi nelle condizioni di poter applicare una delle tre soluzioni.
</p>
</project>

<project title="I principi DRY & KISS">
<p>
   "Do Not Repeat Yourself" e "Keep It Simple And Stupid" sono capi saldi
   della programmazione. C'è chi si spinge oltre con "non commentate il
   codice, riscrivetelo" ossia scrivere codice autoesplicante 
   (poiché è scritto è già tale, forse il riferimento è ad altro). 
   Vedremo degli esempi.
</p>
</project>

<project title="In principio erano i memory leak">
<p>
   Quando la programmazione era solo strutturata e lo sviluppo software
   partiva quasi dal nulla, il <b>programmatore</b> doveva necessariamente <b>sviluppare diligenza</b> e
   chiudere tutto ciò che apriva.
</p>
<p>
   Poi vennero il <b>Garbage Collector e nuovi paradigmi di programmazione
   astratta</b> che ancora oggi promettono al programmatore
   di poter dimenticare tutta una serie di fastidiosi doveri. Il concetto
   dell'OOP nasce da un'idea di Alan Kay che ha dichiarato di non 
   aver mai pensato ad un linguaggio. Il suo
   accostamento alla biologia era solo un'analogia. La biologia
   tratta più di due o tre livelli (classe/istanza o
   modello/classe/interfaccia). Con famiglia, regno e quant'altro ne ha almeno
   nove. Ogni semplificazione implica una riduzione e ogni obbligo è anche un impedimento.
</p>
<p>
   Nel linguaggio delle LEGO, se i mattoncini rappresentano il carattere e la loro combinazione forma la personalità.
   Se funzioni e tipi base sono i mattoncini. Le LEGO moderne sono più bene in quanto più vicine al prodotto rappresentato.
   L'aumento dei micro-pezzettini e la loro specializzazione ha ridotto la creatività. Probabilmente si possono fare anche
   più cose, ma è richiesta maggiore creatività ed immaginazione. Ciò scoraggia l'inventiva.
</p>
</project>

<project title="Come ammazzare un QuadCore con due righe di codice">
<p>
	Quando ho cominciato questo mestiere, le CPU erano a 4Mhz e i computer avevano 16KB di RAM, grafica inclusa.
</p>
<pre>
   S = "", I = 0
   <b>WHILE</b> ( I++ < 5000000 ) <b>DO</b> S = S + "0123456789"
</pre>
<p>
   Questo semplice programma esegue il concatenamento di 10 caratteri
   per 5 milioni di volte. Richiede solo 1/1000 della memoria di cui sono dotati i computer moderni. 
   E' un esempio forzato, ma su un processore a 3GHz, verrebbe eseguito in un millesimo di secondo
   (1/3000000000*5000000).
</p>
<p>
   In pratica arriverà invece a saturare anche un computer potente,
   poiché quella che dovrebbe essere un concatenamento (progressivo) è in
   realtà una somma, ossia un'operazione ripetitiva che si porta dietro il
   pregresso.
</p>
<p>
   Il C++ capisce che la somma è un concatenamento ed ottimizza. C# NON lo faceva, almeno fino alla versione 6.
   Vorrei sapere se Haskell lo fa e come risolve questa situazione.
</p>
<p>
   Chi NON ha esperienza di programmazione a basso livello, potrebbe non
   scoprirlo mai, concludendo che sia necessario scalare l'hardware.
</p>
<p>
	Questo problema affligge maggiormente nell'uso di oggetti e la dove ci sia gestione di memoria con il Garbage Collector.
</p>
</project>

<project title="Polimorfismo">
<p>
   Prima dell'OOP si vedeva codice tipo:
   <pre>
      if action = costante then
      else if action = ...
   </pre>
   Dopo l'OOP si vede codice tipo:
   <pre>
      if typeOf action is ....
   </pre>
</p>
</project>

<project title="GUID per ogni occasione">
<p>
   Vedo spesso usare il GUID come chiave per ovvie ragioni di
   unicità. E' utile soprattutto in previsione di una sincronizzazione tra
   sistemi diversi anche se appartenenti alla stessa soluzione (es.
   mobile<->server). Anche questa è una soluzione psicologicamente di
   comodo. Un INT indirizza quattro miliardi di records ed è più che
   sufficiente.
</p>
<p>
   Quel che un programmatore sa è che un INT occupa 4bytes e un GUID
   16bytes. Può non sapere che un
   processore a 32 ha una word di registro che contiene l'INT ma
   ne deve impiegare 4 per un GUID. Ciò vuol dire che (sempre esempio
   forzato), un processore a 3GHz potrebbe gestire 3 miliardi di ID di tipo INT
   al secondo. Diventano 700 milioni in caso di GUID. Ovviamente sappiamo che già questo numero va ben oltre la realtà.
</p>
</p>
   Le implicazioni sono tante. Ho potuto però dimostrare ai membri del mio
   team che una sincronizzazione PDA/SERVER che mandava in crash il PDA
   con 3000 records con GUID, raggiungeva i 15000 con l'INT. Poi
   abbiamo risolto mandando l'intero archivio, ma non ho detto loro che si
   poteva migliorare di un fattore 10 le prestazioni con un semplice [segreto].
</p>
</project>

<project title="La ricerca è lenta, aggiungiamo un indice">
<p>
   Rimanendo in tema databases, mi è capitato tanto di dover spiegare cosa
   e come aggiungere indici, quanto <b>perché toglierli o fare a meno</b>. Se da
   una parte è abbastanza intuibile che un indice appesantisce la fase di
   scrittura, si pensa meno che una scrittura può implicare una
   lettura. Figuriamoci in ambiente ad alta concorrenza, magari su server monolitico.
</p>
<p>
   Per questioni di scelte progettuali, questo problema può rendere
   addirittura un prodotto gratuito come <b>Postresql più interessante di una
   licenza MSSql</b> Server Enterprise da 150.000€.
</p>
<p>
   Ma <b>quel che sfugge</b> per carenza di knowledge base (KB) è che una lettura
   tramite indice può sfociare certamente in una letura diretta di una pagina, ma questa è come
   <b>sparpagliata in una stanza assieme alle altre</b>. Vediamo la grafica.
</p>
<p>
   La figura 1 è una raffigurazione convenzione di indice a sinistra e tabella a destra.
</p>

   <img src="../images/dbidxtbl.png">  fig.1

<p>
   Nel vecchio dBase, queste due strutture costituivano due
   files. Oggi finiscono in un unico file rappresentabile come in figura 2.
</p>

   <img src="../images/dbsinglefile.png"> fig.2

<p>
   La figura 2 verrebbe utile per far capire perché MSSQL richiede meno
   risorse di Oracle ma allo stesso tempo degrada esponenzialmente in
   performance. Non è questo però l'oggetto del paragrafo.
</p>
<p>
   Questa vista logica, nella realtà diventa qualcosa di simile alla figura 3.
</p>

   <img src="../images/dbdisk.png"> fig.3

<p>
   Ricordo che sono delle rappresentazioni forzate. Lo sparpagliamento può essere minore,
   grazie alle proprietà del file system o alle capacità del sistema
   operativo ma può essere anche maggiore a seconda della configurazione
   software o hardware. Quando non sono HP e Oracle a lavorare assieme, 
   spesso le configurazioni software e hardware non c'entrano nulla l'una con l'altra.
</p>
<p>
   Questo vale sia per SQL che noSQL. Già qualche
   sostenitore del noSQL si sta ricredendo. Ne ho visti tanti di entusiasmi smorzarsi dopo il primo decennio.
   Se ci sono più di 800 linguaggi di programmazione ma il C rimane tra i primi 10 più usati, ci sarà un motivo.
   Mi stupisce sempre sentire di performance eccelse di strumenti quali ad esempio Node.js.
   Azzarderei a dire che le performance di sviluppo sono inversamente proporzionali alle prestazioni di runtime.
</p>
<p>
   <b>Per un'analisi di differenza di normalizzazione in caso di un Document System Management, 
   seguire questo <a href="dsm_normalization.html">link</a><b>
</p>
</project>

<project title="10 piccole query">
<p>
	10 piccole query su mono processo possono essere più veloci di una query complessa ottimizzata in automatico dall'engine su CPU multithread.
</p>
</project>

<project title="DRY e normalizzazione">
<p>
   La <b>"normalizzazione"</b> è il principio DRY per i databases. Tuttavia la descrizione dell'articolo deve essere duplicata
   nella bolla/fattura perche sono documenti ufficiali. Nel mondo noSQL la ridondanza dei dati fa anche bene alla distribuzione, per il
   bilanciamento di carico etc. <br>
   Ci sono anche casi in cui è bene duplicare il codice. Ad esempio, per chi si è imbattuto in ORM fai da te, 
   che omettono tutta una serie di features degli engine DB tipo la gestione delle transazioni o 
   la gestione delle dipendenze, eseguire un'operazione di copia con versionamento risulta in 4 operazioni di I/O anziché in una transazione unica.
   Se l'ORM è stato scritto con tutti i crismi, le 4 operazioni risulteranno in un unica classe od oggetto riciclato 4 volte ma con problemi di gestione della concorrenza. 
   Per farla breve è più utile ridondare il codice per ridurre la complessità (più chiarezza e semplicità) ed equalizzare la cultura del team.   
</p>
</project>

<project title="By-Design">
<p>
Quando bisognava modificare un programma, 20 anni fa, si aggiungeva un parametro o un campo ad una struttura e poi il relativo codice.
A volte poteva bastare aggiungere un ID ed espandere uno switch o appliare l'uso della parte variabile della struttura. Oppure in C c'erano le UNION, ma è acqua passata.
Poi qualcuno ha detto che così non andava bene perché tra puntatori e chi metteva i campi in mezzo e il cast etc., insomma si spaccava tutto.
Così ha inventato l'OOP e poi le interface. Rimane il problema che tra chi chiede, chi prende in carico e chi esegue, non devono conoscere per il principio di disaccoppiamento, al fine di mantenere gli oggetti riciclabili.
Ad ognuno viene dato il set di informazioni limitato a ciò che lo interessa. Ad esempio chi salva un dato, non sa che è nel contesto di una copia carbone.
Ed ecco che quel che è originato come un dato di tipo CopiaCarbone, finisce con un tipo SalvaRecord intermediato da un tipo SalvaConCopiaSorgente tutti in religioso rispetto dell'interfaccia comune.
</p>
</project>

<project title="XLS">
<p>
<pre>"L'organizzazione di un'azienda è inversamente proporzionale al numero di fogli XLS che usa."</pre>
Questa non è mia, ma la sottoscrivo. Se già rigide strutture possono contenere dati assurdi tramite campi sovradimensionati o note, 
figuriamoci cosa può fare una cella Excel che può cambiare natura. Sfortunatamente in un periodo in cui molti individui
sono quantitativamente troppo istruiti, dimentichiamo che una piccola differenza di qualità fa una grande differenza nel lungo periodo.
</p><p>
Una soluzione "smart" può sembrare frutto di genialità e creatività, ma potrebbe solo gestire il problema senza risolverlo.
</p>
</project>

<project title="JSON?">
<p>
   Adoro il formato JSON. Semplice da  scrivere, sempre elegante, comodo da
   modificare, impossibile da ristrutturare, non supporta stringhe multi riga e consuma quanto l'XML. 
   Ma è quanto di meglio c'è e lo possiamo far generare lato server.
</p>
<p>
   JSON in SQL o noSQL? Un bel dilemma. Javascript era nato per rappresentare più che per trasformare. L'analisi richiede almeno 4 livelli di revisione.<br>
</p>
</project>

<project title="E poi vennero Web e Cloud">
<p>
   Sento spesso lamentare del fatto che il browser web impegna la CPU al
   100% o del timore delle applicazioni web, soprattutto SPA, per il consumo di memoria. 
   Eppure le applicazioni
   web, per la loro natura distribuita, dovrebbero ridurre questi problemi
   rispetto alle vecchie applicazioni client/server.  Perché non è così?
</p>
<p>
   Partiamo dalla CPU. Perché è lecito comprare una Ferrari che fa i
   300Km/h quando i limiti di velocità sono inferiori, ma non va bene se
   un'unità di calcolo viene sfruttata al massimo?
</p>
<p>
   L'applicazione web gira in uno dei tab del browser che è
   un'applicazione che gira nel sistema operativo assieme ai venti fogli
   Excel o documenti Word aperti contemporaneamente. Quel che una vecchia
   applicazione client nativa faceva senza dire niente a nessuno era
   spesso impiegare tanti files temporanei senza poi pulire.
</p>
<p>
   Con questo voglio solo concludere che per il principio di Heisemberg,
   non si può fare un'applicazione a prova di utonto o webete.
</p>
<p>
   O meglio, se lo chiedete a me, ve la posso fare, ma per onestà
   intellettuale vi chiederei:
</p>
<p>
   "Siete pronti a spendere più di quanto costerebbe scrivere due
   documenti in croce e fare formazione, magari implementando CMS o
   documentali o di knowledge sharing in genere?"
</p>
<p>
   Certo bisogna assumere le persone giuste, soprattutto quelle che si
   occupano dell'assunzione delle persone giuste.
</p>
<p>
	Personalmente ho provato a fare una webapp molto semplice di cui conosco le performance su un vecchio PC x86 a 8Mhz con 1MB di RAM.
	Girava in maniera accettabile su un iPhone3. Appena aggiunto il più semplice dei CSS, è diventata inaccettabile.
</p>
</project>

<project title="Ho visto cose che voi umani...">
<pre>
   <b>TRY</b>

         VARIABILE = ALTRA_VARIABILE

   <b>END TRY</b>
</pre>
<p>
   Abbiamo visto tutti almeno una volta usare eccezioni a modo di:
   "Chissenefrega, basta che non si spacchi che puoi vendere bugs come
   fossero features":
</p>
<p>
   <b>Ho visto</b> programmi C++ che facevano un uso raffinato dei templates
   (AGG). Al momento di usarli ho lasciato perdere. Troppo complessi. Poi mi sono accorto anche che quando il gioco si fa
   duro, solo l'hardware può giocare e non c'è ottimizzazione software che possa competere.
</p>
<p>
   <b>Ho visto</b> programmi fare uso di interface in maniera magistrale, in un
   potpourri di codice auto esplicante. Poi è arrivato il <b>neolaureato con
   esperienza</b>. Il <b>NcE</b> esiste per convenzione del 60% degli annunci di ricerca italiani.
   In barba ad Heisemberg viene assunto da selezionatori Nce. 
   Naturalmente c'è un referente che sa tutto ma non
   dice niente e non ha mai avuto il tempo di scrivere l'ABC. 
   Altro che metodo Toyota o principio 80/20. Tra teoria e pratica non c'è nient'altro che un muro.
</p>
<p>
   Fresco di tutte le sante neo teorie accademiche, il nostro NcE guarda il problema diritto negli occhi e capisce che ha
   bisogno di weaponX(). Funzione, classe o metodo che sia, la implementa.
   Un colpo al cerchio e uno alla botte e va che è un piacere.
   Quando diventa esperto anche dell'applicazione, scopre che esisteva già
   e si chiamava weapon_YX(). Ormai è tardi per riscrivere il codice
   perché c'è un nuovo problema all'orizzonte o addirittura un nuovo
   lavoro. Così il nuovo NcE wrappa weaponX su weapon_YX giusto per
   mettere un poco di ordine senza sconvolgere. Poi arriva il nuovo-nuovo NcE.
</p>
<p>
   <b>Ho visto</b> usare prefissi "XXX_","AAA_" e altro alle tabelle temporanee dove avevo imposto il prefisso TMP. Alla fine
   l'azienda ha preferito fare a meno di me e investire il ricavato in altri apprendisti. 
   Tutto questo mentre stavo sviluppando triggers DDL che istruissero gli apprendisti all'uso corretto di nomi e commenti, 
   senza perdere tempo a scrivere documentazione che nessuno legge o gli viene dato il tempo per farlo.
</p>
<p>
   <b>Ho visto</b> banali <span class="orange">"SELECT qualcosa FROM tabella WHERE condizione"</span>
   seppellite sotto strati e strati di codice da far piangere (è la nuova programmazione a cipolla),
   10 passaggi, alcuni ricorsivi, di 30 istruzioni, equivalenti ad 1 passaggio di 10 istruzioni SQL92. 
</p>
<p>
	<b>Ho visto</b> professionisti(che di fatto sono solo lavoratori autonomi) scrivere codice inutilmente suvrastrutturato, 
	perché erano abituati così e quindi per loro era più facile e veloce.
</p>
<p>
	<b>Ho visto</b> utenti dichiarare che il programma aveva dato errore X ma senza visualizzare il messaggio.
</p>
<p>
	<b>Ho visto</b> tanti workaround di difetti di progettazione produrre qualcosa tipo un jumbo con i freni di una bicicletta.
</p>
<p>
	<img src="../images/pyramid-boxes.jpg"><img src="../images/colour-boxes.jpg">
</p>
<p>
   <b>Ho lavorato</b> alla manutenzione di 2.000.000 di righe di codice scritto con tutti i crismi OO e dei patterns & C.. e mi sono chiesto se 
   sia più facile cercare una scatola tra 4.000.000 disposte in piano ad array, 
   oppure una in 2.000.000 disposte a piramide, che per di più contiene solo un riferimento astratto alla vera scatola.
</p>
<p>
	<b>Ho inseguito</b> oggetti dentro metodi annidati che ritornavano un oggetto <b>result</b>. Messi in fila farebbero:
	<pre>
		Return(Return(Return(Return(Return(Return(Return(object)))))))
	</pre>
	Poi ho dovuto fare una modifica al 4° livello. Questa richiedeva il risultato per sapere se andare oltre.
	Si, lo so, non si capisce. Immaginate di essere al 4° piano di un edificio e di dover salire all'ultimo per sapere se potere proseguire oltre il 4°.
</p>
</project>

<project title="Jenkins e gli Hyper Tests">   
<p>
   Per quanto sopra (frammentazione del codice o mal progettazione) e per questioni di
   sicurezza (con tutta la gente che si assume e se ne va), 
   si sono resi necessari i sistemi automatizzati di
   compilazione e test. Proprio come facevo 25 anni fa quando programmavo in C, anche se ero da solo.
</p>
<p>
   A quel tempo le grosse applicazioni si dividevano verticalmente in
   librerie e orizzontalmente in chunks di funzioni. Oggi ci sono i
   namespaces e le classi ma dobbiamo mettere i progetti nei posti sbagliati
   solo perché le soluzioni non prevedono links simbolici.
</p>
<p>
	Testare è una scienza o un'arte? Mi chiedo questo perché la scienza sa di non sapere ciò che a volte i tests presuppongono di conoscere. 
	<ul>
		<li>
			Quanto costa, testare le differenze di rappresentazione tra Firefox e Chrome?
		</li>
		<li>
			Come fare a testare una procedura basata su un input casuale dell'utente?
		</li>
		<li>
			Ha senso fare un test su una funzione deterministica? O una funzione tipo ADD(X,Y)?
		</li>
		<li>
			Come fare a testare la mancanza di formazione nell'utente che dice che il programma non va perché manca la carta nella stampante?
		</li>
		<li>
			E quando l'utente dice che il programma è andato in errore ma non lo ha visualizzato?
		</li>
		<li>
			Ha senso scrivere un test per un problema da difetto di progettazione di cui l'analista (NcE) non si rende conto?
		</li>
	</ul>
	Sembra essere comunque corretto assegnare anche questa attività ad un NcE. 
	Il computer più potente del mondo, sviluppato da Google e IBM, raggiunge appena il 4.5% delle capacità del cervello umano.
	Quindi prendiamo un super computer biologico e ne riduciamo la capacità al 4,5% per fargli scrivere piccoli programmi, per testare grandi programmi, che cambiano nel tempo.
</p>
</project>

<project title="Complichiamoci la vita">
<p>
   Nel tentativo di semplificare, per amore
   della scoperta e tanti altri motivi ignobili, mi sono complicato la vita.
</p>
<p>
   Cosa c'era di male in:
</p>
<pre>
   <b>function</b> ClientiInsolventi( filtro ) {

      <b>return</b> db($<span class="orange">"SELECT campoA, campoB, campoC FROM tabella WHERE campoD = {filtro}"</span>)

   }
</pre>
<p>
   E' compatibile con il 100% dei db engine compatibili SQL92. Al più si
   mette un <b>IF dbEngine=X THEN ... ELSE ...</b> in funzione del rapporto di
   Pareto. In oltre rispetta i principi DRY e KISS.
</p>
<p>
   Ma anche io ho preferito qualcosa di più <span class="orange">colorato</span> come:
</p>
<pre>
   ClientiInsolventi <b>Insolventi</b> <op>=</op> db
            .<cmd>From</cmd>&lt;<cmd>ClientiInsolventi</cmd>&gt;()
            .<cmd>Where</cmd>(x <op>=></op> x.campoD <op>=</op> filtro)
            .<cmd>Select</cmd>(x <op>=> <b>new</op></b> { x.campoA, x.CampoB, x.CampoC }

   )
</pre>
<p>
   E' compatibile con il semantic check dell'IDE, difficile da scrivere,
   specifico di uno dei tanti linguaggi general pourpose. Comunque
   diverrà SQL non ottimizzato o non si sa cosa, poiché nessuno ha ancora
   completato il driver ORM per la prossima versione di engine SQL, noSQL, a colonne o
   l'engine che deve ancora venire.
</p>
<p>
	Ovviamente c'è un buon perché. L'obiettivo è l'integrità strutturale e semantica, 
	partendo da una struttura comune (una <b>CLASS</b>) per arrivare in automatico a 
	un <b>CREATE TABLE</b> sul server, ad una <b>PROPERTY</b> Data nella <b>FORM</b> sul client, serializzazione->deserializzazione 
	(automatica grazie alla reflection) e finire con <b>INSERT/UPDATE</b>, per ricominciare con SELECT e chiudere il cerchio.
	Questa pratica deve diramarsi ovunque, anche su cliente web e quindi JSON e Javascript. 
	Ci stiamo arrivando con transpilazione C#/Javascript assieme al webASM, che promette migliori performance.
</p>
<p>
   Serve? Beh poco nei casi in cui l'applicazione consente all'utente di crearsi le strutture dati, tipo i sw documentali.
   Considerando poi che si tende a voler dare strumenti visuali per evitare di far scrivere codice.
   Nulla vieta di generarlo. Insomma, altri dilemmi.
</p>  
<p>
	Si poteva fare anche 20 anni fa? Si. Lo si faceva? Si, perché i programmatori sapevano fare quel che oggi fa l'IDE. Magari si partiva dalla TABLE per ottenere la CLASS e le costanti per i riferimenti.
</p>
<p>
   <b>Gli ORM riducono l'engine a semplice repository intercambiabile e questo da il piacere psicologico della facile scalabilità. 
   Poi non implementano l'atomicità, l'integrità, i trigger DDL e quant'altro maturato in 20 anni di evoluzione, ma ci piace la scalabilità.</b>
</p>
<p>
	Soluzione che sia, in coda partono Jenkins e la sua band che lavorano dietro le quinte, proprio come i vecchi processi batch.
</p>
<p>
   Il software è un eco-sistema. Non si comporta come una ruota di pietra quadrata che a furia di girare si smussa e rivela l'efficacia della rotondità.
</p>
<p>
   Comunque anche la raccolta differenziata insegna che la distribuzione fa risparmiare più della centralizzazione. 
   Basta mettersi d'impegno e fare i conti precisi alla quarta cifra decimale per evitare l'effetto farfalla di Lorenz.
</p>
</project>

<project title="Vedo il tuo bug e rilancio con un deadlock di classi">
<p>
   Qualsiasi linguaggio è un sistema circolare per natura poiché il "nome" non
   è l'"oggetto". A parole, tutto può diventare il suo contrario. 
   Nulla poteva e può impedirci di costruire una funzione A che chiama B che richiama A.
   Non c'è astrazione che lo impedisca. <b>Nulla deve impedirci di creare dal nulla.</b>
</p>
<p>
   Più aumenta la distanza tra le funzioni come il numero di livelli di astrazione, meno individuabile sarà il problema.
   Gli errori semantici possono essere introvabili perché li abbiamo davanti agli occhi.
   Se un sistema pubblico da gli stessi servizi in privato, c'è un conflitto logico.
</p>
<p>
   Tutto parte da un individuo che fa una cosa. Un'altro lo vede e lo
   replica variando qualcosa. Arriva l'osservatore che dice:"Hei, ci sono due entità
   che adottano comportamenti comuni. Facciamone un modello!". Fatto il
   modello, lo si applica in scala e diventa un disastro che starà in piedi
   solo per inerzia.
</p>
<p>
   Non bastano due gambe per tenere in piedi un tavolo
</p>
<p>
   Per rispondere alla richiesta (originata ad un'opinione) di un Duca, i matematici hanno impiegato
   600 anni per dimostrare che non era matematicamente possibile stivare meglio
   le palle di cannone, di come i contadini facevano con le arance. Con più palle di cannone la nave poi sarebbe andata più lenta e quindi bah!
</p>
<p>
   La tridimensionalità è una condizione minima per non
   incappare in errori concettuali. E' una regola che applico
   anche nell'UI design, ma questo è un altra questione.
</p>
</project>

<project title="Team">
<p>
	Lavorare in team è meraviglioso. Se non ci credete, guardatevi Lego Movie.
	Bisogna stare attenti però perché la distinzione tra team e pool è sottile.
	Una volta dissi al membro del mio team di porre delle istruzioni sotto una procedura.
	Il responsabile tecnico, nonché titolare dell'azienda (in italia una persona riveste più ruoli, tanto per incasinarsi ben bene),
	lo vide e lo ammonì (sminuendo per altro il mio ruolo). La sera lo dovetti convincere a rimanere in azienda. Era il più dotato che avevamo.
	Anni dopo criticava le mie proposte. Dopo che l'azienda decise di non avvalersi più delle mie, prestazioni anche lui e altri se ne andarono.
</p>
</project>

<project title="George A. Miller e il magico numero 7+-2">
<p>
	Ho usato questa regola per anni, assieme alla teoria dei sistemi, per raggiungere gli obiettivi nei tempi e costi stimati, senza ritrovarmi grossi problemi in post produzione.
	I programmi come G-Marmo, Tavolinux e SAP Connector che sono sopravvissuti o sopravvivono per otto o più anni senza modifiche, ne sono una testimonianza.
</p>
</project>

<project title="Autoelettriche ibride e LINQ" date="2019-10-16">
<p>Personalmente, e non solo io, trovo la macchina elettrica ibrida uno spreco, anche se probabilmente è un passaggio necessario per far cassa da investire in innovazione.
Credo che un'auto elettrica ibrida non dovrebbe essere un bimotore, bicircuito, etc. con il doppio della complessità. Sarebbe più utile e semplice una macchina totalmente elettrica, 
con un piccolo motore a benzina che fa da generatore di riserva.</p>
<p>Pensiamo a cosa fa un ORM. Partiamo da un engine DB. Esso viene scritto in un linguaggio a basso livello. 
Definisce una struttura comune che si porta dietro i comandi CRUD da eseguire sui records. 
Poi viene costruito un parser che trasforma costrutti SQL in istruzioni che popolano la struttura base con la finale chiamata alla funzione esecutrice.
</p>
<p>L'ORM usa il linguaggio di basso livello (JAVA,C#,etc.) come astrazione del linguaggio SQL, che è un'astrazione del linguaggio a basso livello.</p>
<p>E' vero che riduce la complessità linguistica. LINQ riesce addirittura ad unificare le modalità di gestione dei dati, dimostrando, per altro, che i costrutti simil-SQL sono più comodi.
E' possibile che se nessuno avesse creato un ORM, oggi LINQ sarebbe solo un'idea vaga. Però qualcuno lamenta problemi di performance. Personalmente 
all'ORM avrei preferito dei templates, ossia una macro soluzione.</p>
<p>Tuttavia ancora una volta il principio di indeterminazione di Heisemberg ci mostra che l'alternanza tra due soluzioni (CISC o RISC?) sarà eterna.
L'HTML è fantastico ma troppo verboso quando infarcito di attributi per fargli fare qualcosa di diverso dalla sua natura.</p>
</project>

<project title="Kiss me the code">
<p>
   Il seguente esempio è tratto dal testo "Clean Code". In alto a destra
   c'è il codice d'origine. A sinistra la revisione dell'autore. In basso
   a destra la mia versione.
</p>
<p>
   L'autore spezza il funzioni più piccole, auto-esplicanti. Non tutti i
   linguaggi consentono nested functions. Una classe non avrebbe senso
   (figuriamoci condita di interfaces :-)
</p>
<p>
   La mia versione sembra scritta da un bambino ordinato, ma fa
   di più. Sempre per il principio di Heisemberg, non si può ottimizzare
   sia per tempo che per spazio. Quindi ho usato "più memoria" replicando
   parti di stringa, in violazione del principio DRY. Il codice è più
   compatto, leggibile, capibile dai vecchi come me e dai NcE. Con il
   tempo risparmiato, ho aggiunto l'internazionalizzabilità.
</p>
<p>
   Rimane incasinabile ma lo trovo improbabile. Si fa prima a
   rifare tutto, riciclando questo codice come pseudo-code.
</p>
<p>
   Ho detto di aver violato il principio DRY ma ritengo che, a livello
   strutturale, lo è anche fare più funzioni. La mia
   violazione del DRY preserva il KISS.
</p>
<div style="display:inline-block; width:100%">
   <code style="background-color: #78c1fb; float:left; display: inline-block; vertical-align: top;">
   <b>// "Clean code" (pg. 28,29)</b>

   <b>private</b>
   <b>void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>public</b> string make(
         <b>char</b> candidate, <b>int</b> count
     )
     {
        createPluralDependentMessageParts(count);

        <b>string</b> guessMessage = string.format(
           "There %s %s %s%s",
           verb, number, candidate,
           pluralModifier
           );

        print(guessMessage);
     }

     <b>private
     void</b> createPluralDependentMessageParts(
         <b>int</b> count
     )
     {
        <b>if</b> (count == 0) thereAreNoLetters();
        <b>else if</b> (count == 1) thereIsOneLetter();
        <b>else</b> thereAreManyLetters(count);
     } // createPluralDependentMessageParts

     <b>private
     void</b> thereAreManyLetters(<b>int</b> count)
     {
        number = integer.toString(count);
        verb = "are";
        pluralModifier = "s";
     } // thereAreManyLetters

     <b>private
     void</b> thereIsOneLetter()
     {
        number = "1";
        verb = "is";
        pluralModifier = "";
     }

     <b>private
     void</b> thereAreNoLetters()
     {
        number = "no";
        verb = "are";
        pluralModifier = "s";
     } // thereAreNoLetters

   } // printGuessStatistics
   </code>

   <div style="float:left; display:grid;">

   <code style="background-color: #8bc34a; display: inline-block; vertical-align: top;">
   <b>// the original code</b>

   <b>private
   void</b> printGuessStatistics(
     <b>char</b> candidate, <b>int</b> count
     )
   {
     <b>string</b> number;
     <b>string</b> verb;
     <b>string</b> pluralModifier;

     <b>if</b> (count == 0) {
        
        number = "no";
        verb = "are";
        pluralModifier = "s";

     } <b>if</b> (count == 1) {

        number = "1";
        verb = "is";
        pluralModifier = "";

     } <b>else</b> {

        number = integer.toString(count);;
        verb = "are";
        pluralModifier = "s";

     }

     <b>string</b> guessMessage = string.format(
        "There %s %s %s%s",
        verb, number, candidate,
        pluralModifier
        );

     print(guessMessage);
   }
   </code>

   <code style="background-color: #ffeb3b; display: inline-block; vertical-align: top;">
   <b>// my revision</b>

   <b>void</b> printGuessStatistics( 
      <b>char</b> candidate, 
      <b>int</b> count 
      )
   {
      string msg;

      <b>if</b> (count == 0)
         msg = TR("There are no {0}s",candidate);

      <b>else if</b> (count == 1)
         msg = TR("There is 1 {0}",candidate);

      <b>else if</b> (count > 1)
         msg = TR("There are {0} {1}s", count, candidate);

      print(msg);
   } // printGuessStatistics
   </code>
   </div>
</div>
</project>

<project title="Commenti e finezze da programmatore">
<p>
	Questo codice iniziava così:
	<pre>
		Public Overridable ReadOnly Property Outcome() As IResult.OutcomeCode Implements IResult.Outcome
	</pre>
	ed era very huge per quel che fa.
	L'ho semplificato per lo scopo didattico:
	<pre>
		function OutCome
			failure = 0, success = 0
			
			For Each result In Me
				If result.Outcome = Success Then success += 1
				If result.Outcome = Failure Then failure += 1

			If failure = Count Then Return Failure
			If success = Count Then Return Success
			Return Partial
	</pre>
	La finezza consiste nel considerare che se Count è zero, il risultato sarà Failure. Ma è voluto o è una fortuita svista?
	In questo caso un commento ci vorrebbe, ma ancora una volta quanto detto da Ritchie("Don't comment code, rewrite it") è valido:
	<pre>
		function OutCome
			failure = 0, success = 0
			if Count = 0 Then Return Failure
			. . .
	</pre>
	Non solo toglie ogni dubbio, ottimizzando la lettura, ma risulta anche più veloce in esecuzione.
</p>
<p>
	Questo esempio è interessante anche per vedere che il codice più prolisso, in termini di descrizione, non è necessariamente più corretto od ottimizzabile dal compilatore.
	
</p>
</project>

<project title="Reddito da lavoro, da eredita(rietà) e di cittadinanza">
<p>
Come nella vita, anche nella programmazione si vuol "ottimizzare" e lavorare meno.
Quindi facciamo una classe in cui si prevede tutto. 
Poi finisce che un dato va riacquisito dinamicamente dall'origine, quando viene usato.
Per tagliar corto, quando un membro di un oggetto è valorizzato con quello di un altro, per ogni evenienza, bisognerebbe portarsi dietro tutto l'oggetto originale.
Questo va fatto in cascata con tutti i membri di tutti gli oggetti. Non a caso risulterebbe in una cascata che risale.
</p>
</project>

<project title="To OOP or not to OOP, this is the problem">
<p>
	Se organizzare il codice in classi, interfacce e namespaces sarà un bene, quando si è dentro una classe, rimangono i vecchi dilemmi di come strutturare il codice in e nei metodi.
</p><p>
	Ad esempio, nel caso di tre <b>login</b>: da utente dell'applicazione, da utente intranet/dominio e da internet/web, cosa facciamo? Un metodo <b>login(tipo)</b>? 
	Tre metodi <b>LocalLogin, DomainLogin, WebLogin</b>? Questi nomi poi prenderanno forma OOPizzata: DoNormalAuthentication, DoDomainAuthentication, etc.
	Oppure ne facciamo 3 classi con comune interfaccia o classe base con metodo virtuale o overridable o come diavolo lo chiama il linguaggio di turno?
</p>
</project>

<project title="Tributo a Federico Faggin">
<p>
	Ho iniziato a 13 anni da autodidatta. Non sono un genio, è solo passione. Dopo un mese, 
	il BASIC già mi stava stretto. Ho così appreso l'assembler Z80 e le fasi di trasformazione di un codice sorgente in binario, o linguaggio macchina.
	Qualche mese fa mio figlio, in prima elementare, mi ha stupito nel saper fare conti complessi ma si bloccava chiedendogli di procedere passo passo, togliendo o aggiungendo 1, N volte.
	Ricordo con piacere il registro A dello Z80. A sta per accumulatore. Penso che dovremmo introdurre la programmazione dalla prima elementare come già fanno all'estero.
	Benedetto sia Faggin, padre del processore. Se me ne desse la possibilità lavorerei per lui come Hari Seldom fece per R. Daneel Olivaw.  
</p>
</project>

<project title="La macchina (universale) di Turing">
<p>Leggendo il libro slla storia di Turing, capisco che la famosa macchina di Turing è qualcosa che va oltre la mia umile immaginazione. 
Mi limiterò a ricordarne l'aspetto tecnico-pratico. 
Sostanzialmente questa prende ad uno ad uno una serie di codici che rappresentano nomi, valori e operazioni.  
Queste assegnano i valori ai nomi e operano dei confronti. Sulla base del risultato, si può assegnare un valore ad un nome speciale,
il Contatore di Programma. Questo indica il punto successivo in cui la serie deve proseguire. Con ciò si ottiene una macchina universale.</p>
</project>

<project title="MVVM o MVC o Component?">

<p>Classico esempio:</p>
<pre>
	vm = {
		fname,lname: string
		fullname => fname + ' ' + lname
	}
</pre>
<p>Supponiamo di voler legare l'attivazione di lname alla valorizzazione di fname.
Il legame non è più tra i membri del modello ma esce ed entra nel modello grafico, che è ciò che avviene automaticamente tra fullname e il suo controllo.</p>
<pre>
	fname.subscribe(
		f(value) {
			controlOf(lname).disabled = (value == "")
		}
	}
</pre>
<p>Altrimenti sarebbe stato:</p>
<pre>
	controlOf(fname).onCHANGE = f() {
		controlOf(lname).disabled = ( controlOf(fname).value == "" )
	}
</pre>
<p>Quale'è la differenza?
Che il primo è legato allo stato, il secondo all'evento.
Il primo caso, oltre a richiedere meno codice, funziona anche con:</p>
<pre>
	fname = ""
</pre>
<p>Mentre:</p>
<pre>
	controlOf(fname).value = ""
</pre>
<p>Non fa scattare l'evento keyPRESS a cui potrebbe essere legato l'onCHANGE.</p>
<!--
https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle
https://stackoverflow.com/questions/36950582/angular2-mvc-mvvm-or-mv
https://medium.com/javascript-scene/angular-2-vs-react-the-ultimate-dance-off-60e7dfbc379c
-->
</p>
</project>

<project title="Notazione ungara">
<p>
Oggi la n.u. non ha più senso perché gli IDE ci aiutano ad identificare il tipo di identificatore.
In realtà forse non l'ha mai avuta perché le capacità mentali dei più sono limitate e il problema va necessariamente diviso in sottocontesti piccoli a sufficienza da consentire di chiamare le variabili i,k e n.<br>
Eppure c'è chi ancora la usa quasi come se nella sua testa si parlasse in terza persona:"Lei adesso si trova in una variabile di tipo Classe" e quindi abbiamo "clsVar = new Class;".
</p>
</project>

<p>
   Se volete, contattatemi <img src="../images/contact_info_email.jpg"><br><br>
   06.08.2018 Stefano Zaglio
</p>
<pre>
   _______________________________________________________________________

   Fonti bibliografiche
   "Software sytems, failure and success" Pattersons, C.Jones
   "Clean code" Prentice Hall, R.C.Martin
   "Programmazione orientata agli oggetti" Addison Wesley, Brad J.Cox
   "Pragmatic Programmer: From Journeyman to master" Addison Wesley,A.Hunt, D.Thomas
   “Tinycc-devel - mailing list”
   "Da software house a impresa di servizi" Mondadori, M.Bolognani
   "Dai sistemi al pensiero sistemico" FrancoAngeli, P.Mella
   "Oltre la qualità totale" FrancoAngeli, G.Dellacasa, S.Moncini
   "Il principio 80/20. Il segreto per ottenere di più con meno" FrancoAngeli, R.Koch
   "Usiamo la testa" e "Mappe mentali" Frassinelli, Tony Buzan
   "Change" Astrolabio, P.Watzlawick, J.H.Weakland, R.Fish
   "Perchè non possiamo non dirci darwinisti" Rizzoli, E.Boncinelli (2009)
   "Il computer di Dio" e "Il diavolo in cattedra" di Piergiorgio Odifreddi (2000-2003)
   "Verso un'ecologia della mente" Adelphi, G.Bateson (1977)
   “Sviluppare il pensiero nel ritardo mentale” Erickson, P.L. Baldi
   "L'arte di imparare" Mondadori, B.Carey
   [1]Esperienza personale

</pre>
</body>

<script>
	// add headers and summary, then show everything
	var summary = document.querySelector("#summary")
	var projects = document.querySelectorAll("project")
	projects.forEach(function(it){
		var h4 = document.createElement("H4")
		var bookmark = document.createElement("A")
		var title = it.attributes.title.value
		bookmark.name = title
		bookmark.innerText = title
		h4.appendChild(bookmark)
		it.prepend(h4)
		var li = document.createElement("LI")
		bookmark = document.createElement("A")
		bookmark.href="#"+title
		bookmark.innerText = title
		li.appendChild(bookmark)
		summary.appendChild(li)
	})
	document.body.style.display="block"
</script>

</html>
